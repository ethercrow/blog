Automatically generated by Mendeley Desktop 1.15.3
Any changes to this file will be lost if it is regenerated by Mendeley.

BibTeX export options can be customized via Preferences -> BibTeX in Mendeley Desktop

@article{Power2004,
abstract = {We investigate the notion of a comodel of a (countable) Lawvere theory, an evident dual to the notion of model. By taking the forgetful functor from the category of comodels to Set, every (countable) Lawvere theory generates a comonad on Set. But while Lawvere theories are equivalent to finitary monads on Set, and that result extends to higher cardinality, no such result holds for comonads, and that is not only for size reasons: it is primarily because, while Set is cartesian closed, Setop is not. So every monad with rank on Set generates a comonad on Set, but not conversely. Our leading example is given by the countable Lawvere theory for global state: its category of comodels is the category of arrays, yielding a precise relationship between global state and arrays. Restricting from arbitrary comonads to those comonads generated by Lawvere theories allows us to study new and interesting constructions, in particular that of tensor product.},
author = {Power, John and Shkaravska, Olha},
doi = {http://dx.doi.org/10.1016/j.entcs.2004.02.041},
issn = {1571-0661},
journal = {Electronic Notes in Theoretical Computer Science},
keywords = {(co)algebra,(co)model,(co)monad,Lawvere theory,arrays,equivalence of categories,global state},
pages = {297--314},
title = {{Proceedings of the Workshop on Coalgebraic Methods in Computer Science (CMCS)From Comodels to Coalgebras: State and Arrays}},
url = {http://www.sciencedirect.com/science/article/pii/S1571066104051813},
volume = {106},
year = {2004}
}
@article{Matsuda2015,
annote = {Horrible Eq constraint on unlift.

Write the transformation in the standard style.. actually not too bad.

What about impredicativity

What about efficiency

What about degradiation

Unlines is an iso?

new == pure?

polymorphic update

Jeremy: Lt s [String] instead of [Lt s String]

Simon: Coyeneda, why it exists},
author = {Matsuda, Kazutaka and Wang, Meng},
file = {:Users/matt/Documents/paperarchive/Matsuda, Wang/Unknown/Matsuda, Wang - 2015 - Applicative Bidirectional Programming with Lenses.pdf:pdf},
keywords = {12,16,30,bidirectional programming,bidirectionalization,free theorem,functional programming,haskell,having,in software evolution,lens,mations,of the underlying data,playing a substantial role,similarly for model transfor-},
pages = {38--41},
title = {{Applicative Bidirectional Programming with Lenses}},
year = {2015}
}
@article{Loregian2015,
abstract = {The present note is a recollection of the most striking and useful applications of co/end calculus. We put a considerable effort in making arguments and constructions rather explicit: after having given a series of preliminary definitions, we characterize co/ends as particular co/limits; then we derive a number of results directly from this characterization. The last sections discuss the most interesting examples where co/end calculus serves as a powerful abstract way to do explicit computations in diverse fields like Algebra, Algebraic Topology and Category Theory. The appendices serve to sketch a number of results in theories heavily relying on co/end calculus; the reader who dares to arrive at this point, being completely introduced to the mysteries of co/end fu, can regard basically every statement as a guided exercise.},
archivePrefix = {arXiv},
arxivId = {arXiv:1501.02503v2},
author = {Loregian, Fosco},
eprint = {arXiv:1501.02503v2},
file = {:Users/matt/Documents/paperarchive/Loregian/Criticism/Loregian - 2015 - This is the (co) end, my only (co) friend.pdf:pdf},
journal = {Criticism},
keywords = {()},
pages = {439},
title = {{This is the (co) end, my only (co) friend}},
url = {http://arxiv.org/abs/1501.02503},
year = {2015}
}
@article{Chen2014a,
address = {New York, New York, USA},
author = {Chen, Sheng and Erwig, Martin},
doi = {10.1145/2628136.2628155},
file = {:Users/matt/Documents/paperarchive/Chen, Erwig/Proceedings of the 19th ACM SIGPLAN international conference on Functional programming - ICFP '14/Chen, Erwig - 2014 - Type-based parametric analysis of program families.pdf:pdf},
isbn = {9781450328739},
journal = {Proceedings of the 19th ACM SIGPLAN international conference on Functional programming - ICFP '14},
keywords = {1,10,17,19,22,23,24,25,5,analysis lifting,choice calculus,constraint-based type system,dataflow analysis,model,of much research,of parsing,program families,static-,such as the variationalization,type checking,variational types},
pages = {39--51},
publisher = {ACM Press},
title = {{Type-based parametric analysis of program families}},
url = {http://dl.acm.org/citation.cfm?doid=2628136.2628155},
year = {2014}
}
@article{Gist,
author = {Gist, Issues},
file = {:Users/matt/Documents/paperarchive/Gist/Unknown/Gist - Unknown - Consider pure profunctor lenses {\#} 26.pdf:pdf},
title = {{Consider " pure profunctor " lenses {\#} 26}}
}
@article{Pfenning1988,
author = {Pfenning, Frank and Elliot, C},
file = {:Users/matt/Documents/paperarchive/Pfenning, Elliot/ACM SIGPLAN Notices/Pfenning, Elliot - 1988 - Higher-order abstract syntax.pdf:pdf},
journal = {ACM SIGPLAN Notices},
number = {5404},
title = {{Higher-order abstract syntax}},
url = {http://dl.acm.org/citation.cfm?id=54010},
year = {1988}
}
@article{Co-investigator2013,
abstract = {Predicting the binding mode of flexible polypeptides to proteins is an important task that falls outside the domain of applicability of most small molecule and protein−protein docking tools. Here, we test the small molecule flexible ligand docking program Glide on a set of 19 non-$\alpha$-helical peptides and systematically improve pose prediction accuracy by enhancing Glide sampling for flexible polypeptides. In addition, scoring of the poses was improved by post-processing with physics-based implicit solvent MM- GBSA calculations. Using the best RMSD among the top 10 scoring poses as a metric, the success rate (RMSD ≤ 2.0 {\AA} for the interface backbone atoms) increased from 21{\%} with default Glide SP settings to 58{\%} with the enhanced peptide sampling and scoring protocol in the case of redocking to the native protein structure. This approaches the accuracy of the recently developed Rosetta FlexPepDock method (63{\%} success for these 19 peptides) while being over 100 times faster. Cross-docking was performed for a subset of cases where an unbound receptor structure was available, and in that case, 40{\%} of peptides were docked successfully. We analyze the results and find that the optimized polypeptide protocol is most accurate for extended peptides of limited size and number of formal charges, defining a domain of applicability for this approach.},
archivePrefix = {arXiv},
arxivId = {arXiv:1011.1669v3},
author = {Day, Brian},
doi = {10.1017/CBO9781107415324.004},
eprint = {arXiv:1011.1669v3},
file = {:Users/matt/Documents/paperarchive/Day/Reports of the Midwest Category Seminar IV/Day - 1969 - ON CLOSED CATEGORIES OF FUNCTORS.pdf:pdf},
isbn = {9788578110796},
issn = {1098-6596},
journal = {Reports of the Midwest Category Seminar IV},
keywords = {icle},
pages = {1689--1699},
pmid = {25246403},
title = {{ON CLOSED CATEGORIES OF FUNCTORS}},
year = {1969}
}
@article{Heunen2006,
author = {Heunen, Chris and Jacobs, Bart},
doi = {10.1016/j.entcs.2006.04.012},
file = {:Users/matt/Documents/paperarchive/Heunen, Jacobs/Electronic Notes in Theoretical Computer Science/Heunen, Jacobs - 2006 - Arrows, like Monads, are Monoids.pdf:pdf},
issn = {15710661},
journal = {Electronic Notes in Theoretical Computer Science},
keywords = {arrow,bifunctor,freyd category,monad,monoid},
month = {may},
pages = {219--236},
title = {{Arrows, like Monads, are Monoids}},
url = {http://linkinghub.elsevier.com/retrieve/pii/S1571066106001666},
volume = {158},
year = {2006}
}
@article{Cockx2014,
address = {New York, New York, USA},
author = {Cockx, Jesper and Devriese, Dominique and Piessens, Frank},
doi = {10.1145/2628136.2628139},
file = {:Users/matt/Documents/paperarchive/Cockx, Devriese, Piessens/Proceedings of the 19th ACM SIGPLAN international conference on Functional programming - ICFP '14/Cockx, Devriese, Piessens - 2014 - Pattern matching without K.pdf:pdf},
isbn = {9781450328739},
journal = {Proceedings of the 19th ACM SIGPLAN international conference on Functional programming - ICFP '14},
keywords = {dependent pattern matching,homotopy,k axiom},
pages = {257--268},
publisher = {ACM Press},
title = {{Pattern matching without K}},
url = {http://dl.acm.org/citation.cfm?doid=2628136.2628139},
year = {2014}
}
@article{Wan2000,
author = {Wan, Zhanyong and Hudak, Paul},
doi = {10.1145/358438.349331},
file = {:Users/matt/Documents/paperarchive/Wan, Hudak/ACM SIGPLAN Notices/Wan, Hudak - 2000 - Functional reactive programming from first principles.pdf:pdf},
isbn = {1581131992},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
month = {may},
number = {5},
pages = {242--252},
title = {{Functional reactive programming from first principles}},
url = {http://portal.acm.org/citation.cfm?doid=358438.349331},
volume = {35},
year = {2000}
}
@techreport{Aitken1992,
author = {Aitken, William E and Reppy, John H},
file = {:Users/matt/Documents/paperarchive/Aitken, Reppy/Unknown/Aitken, Reppy - 1992 - Abstract Value Constructors.pdf:pdf},
title = {{Abstract Value Constructors}},
year = {1992}
}
@article{Gustavson2011,
author = {Gustavson, Stefan and Strand, Robin},
doi = {10.1016/j.patrec.2010.08.010},
file = {:Users/matt/Documents/paperarchive/Gustavson, Strand/Pattern Recognition Letters/Gustavson, Strand - 2011 - Anti-aliased Euclidean distance transform.pdf:pdf},
issn = {01678655},
journal = {Pattern Recognition Letters},
month = {jan},
number = {2},
pages = {252--257},
publisher = {Elsevier B.V.},
title = {{Anti-aliased Euclidean distance transform}},
url = {http://linkinghub.elsevier.com/retrieve/pii/S0167865510002953},
volume = {32},
year = {2011}
}
@article{Li2005,
abstract = {We demonstrate the Haskell Refactorer, HaRe, both as an example of a fully-functional tool for a complete (functional) programming language, and to show the API which HaRe provides for building source-level program transformations for Haskell. We comment on the challenges presented by the construction of this and similar tools for language frameworks and processors. © 2005 Elsevier B.V. All rights reserved.},
author = {Li, Huiqing and Thompson, Simon and Reinke, Claus},
doi = {10.1016/j.entcs.2005.02.053},
file = {:Users/matt/Documents/paperarchive/Li, Thompson, Reinke/Electronic Notes in Theoretical Computer Science/Li, Thompson, Reinke - 2005 - The Haskell Refactorer, HaRe, and its API.pdf:pdf},
issn = {15710661},
journal = {Electronic Notes in Theoretical Computer Science},
keywords = {HaRe,Haskell,Layout preservation,Program transformation API,Programatica,Refactoring,Source code,Strafunski,Strategic programming},
pages = {29--34},
title = {{The Haskell Refactorer, HaRe, and its API}},
volume = {141},
year = {2005}
}
@inproceedings{Li2003,
address = {New York, NY, USA},
author = {Li, Huiqing and Reinke, Claus and Thompson, Simon},
booktitle = {Proceedings of the 2003 ACM SIGPLAN Workshop on Haskell},
doi = {10.1145/871895.871899},
file = {:Users/matt/Documents/paperarchive/Li, Reinke, Thompson/Proceedings of the 2003 ACM SIGPLAN Workshop on Haskell/Li, Reinke, Thompson - 2003 - Tool Support for Refactoring Functional Programs.pdf:pdf},
isbn = {1-58113-758-3},
keywords = {Haskell,language-aware programming environments,program transformation,refactoring,semantic editors},
pages = {27--38},
publisher = {ACM},
series = {Haskell '03},
title = {{Tool Support for Refactoring Functional Programs}},
url = {http://doi.acm.org/10.1145/871895.871899},
year = {2003}
}
@article{Mcbride2008,
author = {McBride, Conor and Paterson, Ross},
doi = {10.1017/S0956796807006326},
file = {:Users/matt/Documents/paperarchive/McBride, Paterson/Functional Programming/McBride, Paterson - 2008 - FUNCTIONAL PEARL Applicative programming with e ects.pdf:pdf},
journal = {Functional Programming},
pages = {1--13},
title = {{FUNCTIONAL PEARL Applicative programming with e ects}},
volume = {18},
year = {2008}
}
@techreport{Ryder2005,
author = {Ryder, Chris and Thompson, Simon},
file = {:Users/matt/Documents/paperarchive/Ryder, Thompson/Unknown/Ryder, Thompson - 2005 - Technical Report - Porting HaRe to the GHC API.pdf:pdf},
pages = {182--196},
title = {{Technical Report - Porting HaRe to the GHC API}},
year = {2005}
}
@article{Filinski1994,
address = {New York, New York, USA},
author = {Filinski, Andrzej},
doi = {10.1145/174675.178047},
file = {:Users/matt/Documents/paperarchive/Filinski/Proceedings of the 21st ACM SIGPLAN-SIGACT symposium on Principles of programming languages - POPL '94/Filinski - 1994 - Representing monads.pdf:pdf},
isbn = {0897916360},
journal = {Proceedings of the 21st ACM SIGPLAN-SIGACT symposium on Principles of programming languages - POPL '94},
pages = {446--457},
publisher = {ACM Press},
title = {{Representing monads}},
url = {http://portal.acm.org/citation.cfm?doid=174675.178047},
year = {1994}
}
@article{Moggi1991,
author = {Moggi, Eugenio},
doi = {10.1016/0890-5401(91)90052-4},
file = {:Users/matt/Documents/paperarchive/Moggi/Information and Computation/Moggi - 1991 - Notions of computation and monads.pdf:pdf},
issn = {08905401},
journal = {Information and Computation},
month = {jul},
number = {1},
pages = {55--92},
title = {{Notions of computation and monads}},
url = {http://linkinghub.elsevier.com/retrieve/pii/0890540191900524},
volume = {93},
year = {1991}
}
@article{Gibbons2015,
author = {Gibbons, Jeremy},
doi = {10.1016/j.jlamp.2015.10.006},
file = {:Users/matt/Documents/paperarchive/Gibbons/Journal of Logical and Algebraic Methods in Programming/Gibbons - 2015 - Kernels, in a nutshell.pdf:pdf},
issn = {23522208},
journal = {Journal of Logical and Algebraic Methods in Programming},
pages = {1--10},
publisher = {Elsevier Inc.},
title = {{Kernels, in a nutshell}},
url = {http://linkinghub.elsevier.com/retrieve/pii/S235222081500111X},
volume = {1},
year = {2015}
}
@article{Achten2010,
author = {Steckermeier, Albert},
doi = {10.1017/S0956796803214878},
file = {:Users/matt/Documents/paperarchive/Steckermeier/Unknown/Steckermeier - 2015 - Lenses in Functional Programming.pdf:pdf},
isbn = {9783642229404},
issn = {09567968},
keywords = {artificial life,domain specific language,haskell},
pages = {68--83},
title = {{Lenses in Functional Programming}},
url = {http://www.mendeley.com/research/lecture-notes-computer-science-2/$\backslash$nhttp://books.google.com/books?hl=en{\&}amp;lr={\&}amp;id=2Ze2EnsCDxgC{\&}amp;oi=fnd{\&}amp;pg=PP1{\&}amp;dq=Trends+in+Functional+Programming{\&}amp;ots=mjnkRXTVz2{\&}amp;sig=T05eNbbLFPRDQFkT1LTBsKCVMPo},
year = {2015}
}
@article{Morris2014,
address = {New York, New York, USA},
author = {Morris, J. Garrett},
doi = {10.1145/2633357.2633364},
file = {:Users/matt/Documents/paperarchive/Morris/Proceedings of the 2014 ACM SIGPLAN symposium on Haskell - Haskell '14/Morris - 2014 - A simple semantics for Haskell overloading.pdf:pdf},
isbn = {9781450330411},
journal = {Proceedings of the 2014 ACM SIGPLAN symposium on Haskell - Haskell '14},
keywords = {overloading,semantics,type classes},
pages = {107--118},
publisher = {ACM Press},
title = {{A simple semantics for Haskell overloading}},
url = {http://dl.acm.org/citation.cfm?doid=2633357.2633364},
year = {2014}
}
@article{Stefan2012,
abstract = {We describe a new, dynamic, floating-label approach to language-based information flow control. A labeled IO monad, LIO, keeps track of a current label and permits restricted access to IO functionality. The current label floats to exceed the labels of all data observed and restricts what can be modified. Unlike other language-based work, LIO also bounds the current label with a current clearance that provides a form of discretionary access control. Computations may encapsulate and pass around the results of computations with different labels. In addition, the LIO monad offers a simple form of labeled mutable references and exception handling. We give precise semantics and prove confidentiality and integrity properties of a call-by-name $\backslash$lambda-calculus and provide an implementation in Haskell.},
archivePrefix = {arXiv},
arxivId = {1207.1457},
author = {Stefan, Deian and Russo, Alejandro and Mitchell, John C. and Mazi{\`{e}}res, David},
eprint = {1207.1457},
file = {:Users/matt/Documents/paperarchive/Stefan et al/Unknown/Stefan et al. - 2012 - Flexible Dynamic Information Flow Control in the Presence of Exceptions.pdf:pdf},
isbn = {9781450330411},
keywords = {6,7,are mediated according to,called lio,dclabels,decentralized infor-,decentralized information flow control,effects in the lio,hails,labeled io,lio,mation flow control,monad,security,web application},
month = {jul},
pages = {93--94},
title = {{Flexible Dynamic Information Flow Control in the Presence of Exceptions}},
url = {http://arxiv.org/abs/1207.1457},
year = {2012}
}
@article{Gibbons,
author = {Gibbons, Jeremy},
file = {:Users/matt/Documents/paperarchive/Gibbons/Unknown/Gibbons - Unknown - for Doaitse Swierstra , on his retirement.pdf:pdf},
title = {{for Doaitse Swierstra , on his retirement}}
}
@article{Wu2015,
abstract = {Algebraic effect handlers are a recently popular approach for modelling side-effects that separates the syntax and semantics of effectful operations. The shape of syntax is captured by functors, and free monads over these functors denote syntax trees. The semantics is captured by algebras, and effect handlers pass these over the syntax trees to interpret them into a semantic domain. This approach is inherently modular: different functors can be composed to make trees with richer structure. Such trees are interpreted by applying several handlers in sequence, each removing the syntactic constructs it recognizes. Unfortunately, the construction and traversal of intermediate trees is painfully inefficient and has hindered the adoption of the handler approach. This paper explains how a sequence of handlers can be fused into one, so that multiple tree traversals can be reduced to a single one and no intermediate trees need to be allocated. At the heart of this optimization is keeping the notion of a free monad abstract, thus enabling a change of representation that opens up the possibility of fusion. We demonstrate how the ensuing code can be inlined at compile time to produce efficient handlers.},
author = {Wu, N and Schrijvers, T},
file = {:Users/matt/Documents/paperarchive/Wu, Schrijvers/Unknown/Wu, Schrijvers - 2015 - Fusion for free efficient algebraic effect handlers.pdf:pdf},
pages = {1--22},
title = {{Fusion for free: efficient algebraic effect handlers}},
url = {https://lirias.kuleuven.be/handle/123456789/499979},
year = {2015}
}
@article{Barthe2003,
author = {Barthe, Gilles and Capretta, Venanzio and Pons, Olivier},
doi = {10.1017/S0956796802004501},
file = {:Users/matt/Documents/paperarchive/Barthe, Capretta, Pons/Journal of Functional Programming/Barthe, Capretta, Pons - 2003 - Setoids in type theory.pdf:pdf},
issn = {0956-7968},
journal = {Journal of Functional Programming},
month = {mar},
number = {02},
pages = {261--293},
title = {{Setoids in type theory}},
url = {http://www.journals.cambridge.org/abstract{\_}S0956796802004501},
volume = {13},
year = {2003}
}
@article{Fowler1999,
abstract = {As the application of object technology-particularly the Java programming language-has become commonplace, a new problem has emerged to confront the software development community. Significant numbers of poorly designed programs have been created by less-experienced developers, resulting in applications that are inefficient and hard to maintain and extend. Increasingly, software system professionals are discovering just how difficult it is to work with these inherited, "non-optimal" applications. For several years, expert-level object programmers have employed a growing collection of techniques to improve the structural integrity and performance of such existing software programs. Referred to as "refactoring," these practices have remained in the domain of experts because no attempt has been made to transcribe the lore into a form that all developers could use. . .until now. In Refactoring: Improving the Design of Existing Software, renowned object technology mentor Martin Fowler breaks new ground, demystifying these master practices and demonstrating how software practitioners can realize the significant benefits of this new process. With proper training a skilled system designer can take a bad design and rework it into well-designed, robust code. In this book, Martin Fowler shows you where opportunities for refactoring typically can be found, and how to go about reworking a bad design into a good one. Each refactoring step is simple-seemingly too simple to be worth doing. Refactoring may involve moving a field from one class to another, or pulling some code out of a method to turn it into its own method, or even pushing some code up or down a hierarchy. While these individual steps may seem elementary, the cumulative effect of such small changes can radically improve the design. Refactoring is a proven way to prevent software decay. In addition to discussing the various techniques of refactoring, Refactoring: Improving the Design of Existing Software provides a detailed catalog of more than seventy proven refactorings with helpful pointers that teach you when to apply them; step-by-step instructions for applying each refactoring; and an example illustrating how the refactoring works. The illustrative examples are written in Java, but the ideas are applicable to any object-oriented programming language.},
author = {Fowler, Martin and Beck, Kent and Brant, John and Opdyke, William and Roberts, Don},
doi = {10.1007/s10071-009-0219-y},
file = {:Users/matt/Documents/paperarchive/Fowler et al/Xtemp01/Fowler et al. - 1999 - Refactoring Improving the Design of Existing Code.pdf:pdf},
isbn = {9780201485677},
issn = {14359456},
journal = {Xtemp01},
pages = {1--337},
pmid = {19263100},
title = {{Refactoring: Improving the Design of Existing Code}},
year = {1999}
}
@article{Li2007,
author = {Li, Peng and Zdancewic, Steve},
doi = {10.1145/1273442.1250756},
file = {:Users/matt/Documents/paperarchive/Li, Zdancewic/ACM SIGPLAN Notices/Li, Zdancewic - 2007 - Combining events and threads for scalable network services implementation and evaluation of monadic, application-.pdf:pdf},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
month = {jun},
number = {6},
pages = {189},
title = {{Combining events and threads for scalable network services implementation and evaluation of monadic, application-level concurrency primitives}},
url = {http://portal.acm.org/citation.cfm?doid=1273442.1250756},
volume = {42},
year = {2007}
}
@article{Li2012,
abstract = {Refactoring is the process of changing the design of a program without changing its behaviour. Many refactoring tools have been developed for various programming languages; their support for composite refactorings {\^{a}}�� refactorings that are composed from a number of primitive refactorings},
author = {Li, Huiqing and Thompson, Simon},
doi = {10.1007/978-3-642-28872-2{\_}34},
file = {:Users/matt/Documents/paperarchive/Li, Thompson/Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)/Li, Thompson - 2012 - A domain-specific language for scripting refactorings in Erlang.pdf:pdf},
isbn = {9783642288715},
issn = {03029743},
journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
keywords = {API,DSL,Erlang,Wrangler,analysis,refactoring,transformation},
pages = {501--515},
title = {{A domain-specific language for scripting refactorings in Erlang}},
volume = {7212 LNCS},
year = {2012}
}
@article{Bahr2011,
address = {New York, New York, USA},
author = {Bahr, Patrick and Hvitved, Tom},
doi = {10.1145/2036918.2036930},
file = {:Users/matt/Documents/paperarchive/Bahr, Hvitved/Proceedings of the seventh ACM SIGPLAN workshop on Generic programming - WGP '11/Bahr, Hvitved - 2011 - Compositional data types.pdf:pdf},
isbn = {9781450308618},
journal = {Proceedings of the seventh ACM SIGPLAN workshop on Generic programming - WGP '11},
keywords = {algebraic programming,deforestation,mu-,reusability},
pages = {83},
publisher = {ACM Press},
title = {{Compositional data types}},
url = {http://dl.acm.org/citation.cfm?doid=2036918.2036930},
year = {2011}
}
@article{Slesarenko2014,
address = {New York, New York, USA},
author = {Slesarenko, Alexander and Filippov, Alexander and Romanov, Alexey},
doi = {10.1145/2633628.2633632},
file = {:Users/matt/Documents/paperarchive/Slesarenko, Filippov, Romanov/Proceedings of the 10th ACM SIGPLAN workshop on Generic programming - WGP '14/Slesarenko, Filippov, Romanov - 2014 - First-class isomorphic specialization by staged evaluation.pdf:pdf},
isbn = {9781450330428},
journal = {Proceedings of the 10th ACM SIGPLAN workshop on Generic programming - WGP '14},
keywords = {domain-specific languages,dsl,generic programming,ing,isomorphisms,multi-stage programming,polytypic programming,scala,programming languages,DSL,generic programmin,specialization,stag-},
pages = {35--46},
publisher = {ACM Press},
title = {{First-class isomorphic specialization by staged evaluation}},
url = {http://dl.acm.org/citation.cfm?doid=2633628.2633632},
year = {2014}
}
@article{Schrijvers2007,
author = {Schrijvers, Tom and Sulzmann, Martin and Jones, Simon Peyton},
file = {:Users/matt/Documents/paperarchive/Schrijvers/{\ldots} and Application of {\ldots}/Schrijvers - 2007 - Towards open type functions for Haskell.pdf:pdf},
number = {Section 3},
pages = {1--19},
title = {{Towards Open Type Functions for Haskell}},
year = {2007}
}
@article{Hinze2012a,
abstract = {Many program optimisations involve transforming a program in direct style to an equivalent program in continuation-passing style. This paper investigates the theoretical underpinnings of this transformation in the categorical setting of monads. We argue that so-called absolute Kan Extensions underlie this program optimisation. It is known that every Kan extension gives rise to a monad, the codensity monad, and furthermore that every monad is isomorphic to a codensity monad. The end formula for Kan extensions then induces an implementation of the monad, which can be seen as the categorical counterpart of continuationpassing style. We show that several optimisations are instances of this scheme: Church representations and implementation of backtracking using success and failure continuations, among others. Furthermore, we develop the calculational properties of Kan extensions, powers and ends. In particular, we propose a two-dimensional notation based on string diagrams that aims to support e ective reasoning with Kan extensions.},
author = {Hinze, Ralf},
doi = {10.1007/978-3-642-31113-0{\_}16},
file = {:Users/matt/Documents/paperarchive/Hinze/Mathematics of Program Construction/Hinze - 2012 - Kan extensions for program optimisation or art and dan explain an old trick.pdf:pdf},
isbn = {978-3-642-31112-3},
issn = {0302-9743},
journal = {Mathematics of Program Construction},
keywords = {adjunction,backtracking,church representation,codensity monad,cps,end,haskell,kan extension,power,string diagram},
pages = {1--39},
title = {{Kan extensions for program optimisation or: art and dan explain an old trick}},
url = {http://link.springer.com/chapter/10.1007/978-3-642-31113-0{\_}16},
year = {2012}
}
@article{Breitner2014,
address = {New York, New York, USA},
author = {Breitner, Joachim and Eisenberg, Richard a. and {Peyton Jones}, Simon and Weirich, Stephanie},
doi = {10.1145/2628136.2628141},
file = {:Users/matt/Documents/paperarchive/Breitner et al/Proceedings of the 19th ACM SIGPLAN international conference on Functional programming - ICFP '14/Breitner et al. - 2014 - Safe zero-cost coercions for Haskell.pdf:pdf},
isbn = {9781450328739},
journal = {Proceedings of the 19th ACM SIGPLAN international conference on Functional programming - ICFP '14},
keywords = {coercion,haskell,html,mk string,module html,newtype deriving,newtype html,text,type class,unmk,where},
pages = {189--202},
publisher = {ACM Press},
title = {{Safe zero-cost coercions for Haskell}},
url = {http://dl.acm.org/citation.cfm?doid=2628136.2628141},
year = {2014}
}
@article{Coecke,
author = {Coecke, Bob and Kissinger, Aleks},
file = {:Users/matt/Documents/paperarchive/Coecke, Kissinger/Unknown/Coecke, Kissinger - Unknown - Picturing quantum processes.pdf:pdf},
title = {{Picturing quantum processes}}
}
@article{Danielsson2006,
abstract = {Functional programmers often reason about programs as if they were written in a total language, expecting the results to carry over to non-total (partial) languages. We justify such reasoning. Two languages are defined, one total and one partial, with identical syntax. The semantics of the partial language includes partial and infinite values, and all types are lifted, including the function spaces. A partial equivalence relation (PER) is then defined, the domain of which is the total subset of the partial language. For types not containing function spaces the PER relates equal values, and functions are related if they map related values to related values. It is proved that if two closed terms have the same semantics in the total language, then they have related semantics in the partial language. It is also shown that the PER gives rise to a bicartesian closed category which can be used to reason about values in the domain of the relation.},
author = {Danielsson, Nils Anders and Hughes, John and Jansson, Patrik and Gibbons, Jeremy},
doi = {10.1145/1111320.1111056},
file = {:Users/matt/Documents/paperarchive/Danielsson et al/ACM SIGPLAN Notices/Danielsson et al. - 2006 - Fast and loose reasoning is morally correct.pdf:pdf},
isbn = {1595930272},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
keywords = {and,equational reasoning,fst x,guages,inductive and coinductive types,lifted types,non-strict and strict languages,partial and infinite,partial and total lan-,snd x,values,x},
number = {1},
pages = {206--217},
title = {{Fast and loose reasoning is morally correct}},
volume = {41},
year = {2006}
}
@article{Bird2013,
author = {Bird, Richard and Gibbons, Jeremy and Mehner, Stefan and Voigtl{\"{a}}nder, Janis and Schrijvers, Tom},
doi = {10.1145/2503778.2503781},
file = {:Users/matt/Documents/paperarchive/Bird et al/the 2013 ACM SIGPLAN symposium/Bird et al. - 2013 - Understanding idiomatic traversals backwards and forwards.pdf:pdf},
isbn = {9781450323833},
issn = {15232867},
journal = {the 2013 ACM SIGPLAN symposium},
keywords = {ads,applicative functors,finitary containers,idioms,mon-,traversable functors},
pages = {25},
title = {{Understanding idiomatic traversals backwards and forwards}},
url = {http://dl.acm.org/citation.cfm?doid=2503778.2503781$\backslash$npapers2://publication/doi/10.1145/2503778.2503781},
year = {2013}
}
@article{Chitil2005,
author = {Chitil, Olaf},
doi = {10.1145/1053468.1053473},
file = {:Users/matt/Documents/paperarchive/Chitil/ACM Transactions on Programming Languages and Systems/Chitil - 2005 - Pretty printing with lazy dequeues.pdf:pdf},
issn = {01640925},
journal = {ACM Transactions on Programming Languages and Systems},
month = {jan},
number = {1},
pages = {163--184},
title = {{Pretty printing with lazy dequeues}},
url = {http://portal.acm.org/citation.cfm?doid=1053468.1053473},
volume = {27},
year = {2005}
}
@article{Uustalu2008,
author = {Uustalu, Tarmo and Vene, Varmo},
doi = {10.1016/j.entcs.2008.05.029},
file = {:Users/matt/Documents/paperarchive/Uustalu, Vene/Electronic Notes in Theoretical Computer Science/Uustalu, Vene - 2008 - Comonadic Notions of Computation.pdf:pdf},
issn = {15710661},
journal = {Electronic Notes in Theoretical Computer Science},
keywords = {cokleisli semantics,context-dependent computation,dataflow computation,monoidal comonads,symmetric,tree transformations},
month = {jun},
number = {5},
pages = {263--284},
title = {{Comonadic Notions of Computation}},
url = {http://linkinghub.elsevier.com/retrieve/pii/S1571066108003435},
volume = {203},
year = {2008}
}
@article{Thompson2001a,
author = {Thompson, Simon and Reinke, Claus},
file = {:Users/matt/Documents/paperarchive/Thompson, Reinke/Unknown/Thompson, Reinke - 2001 - A Catalogue of Functional Refactorings Version 1.pdf:pdf},
number = {August},
title = {{A Catalogue of Functional Refactorings Version 1}},
year = {2001}
}
@article{Kiselyov2013,
author = {Kiselyov, Oleg and Sabry, A and Swords, Cameron},
file = {:Users/matt/Documents/paperarchive/Kiselyov, Sabry, Swords/Proceedings of the 2013 ACM SIGPLAN {\ldots}/Kiselyov, Sabry, Swords - 2013 - Extensible effects an alternative to monad transformers.pdf:pdf},
isbn = {9781450323833},
journal = {Proceedings of the 2013 ACM SIGPLAN {\ldots}},
keywords = {coroutine,effect handler,effect interaction,monad,monad transformer,open union,type and effect system},
title = {{Extensible effects: an alternative to monad transformers}},
url = {http://dl.acm.org/citation.cfm?id=2503791},
year = {2013}
}
@article{Eisenberg2012,
address = {New York, New York, USA},
author = {Eisenberg, Richard a. and Weirich, Stephanie},
doi = {10.1145/2364506.2364522},
file = {:Users/matt/Documents/paperarchive/Eisenberg, Weirich/Proceedings of the 2012 symposium on Haskell symposium - Haskell '12/Eisenberg, Weirich - 2012 - Dependently typed programming with singletons.pdf:pdf},
isbn = {9781450315746},
journal = {Proceedings of the 2012 symposium on Haskell symposium - Haskell '12},
keywords = {dependently typed programming,haskell,singletons},
pages = {117},
publisher = {ACM Press},
title = {{Dependently typed programming with singletons}},
url = {http://dl.acm.org/citation.cfm?doid=2364506.2364522},
year = {2012}
}
@article{Weirich2011,
author = {Weirich, Stephanie and Yorgey, Brent a. and Sheard, Tim},
doi = {10.1145/2034574.2034818},
file = {:Users/matt/Documents/paperarchive/Weirich, Yorgey, Sheard/ACM SIGPLAN Notices/Weirich, Yorgey, Sheard - 2011 - Binders unbound.pdf:pdf},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
keywords = {generic programming,haskell,name binding,patterns},
month = {sep},
number = {9},
pages = {333},
title = {{Binders unbound}},
url = {http://dl.acm.org/citation.cfm?doid=2034574.2034818},
volume = {46},
year = {2011}
}
@article{Voufo2014,
address = {New York, New York, USA},
author = {Voufo, Larisse and Zalewski, Marcin and Lumsdaine, Andrew},
doi = {10.1145/2633628.2633633},
file = {:Users/matt/Documents/paperarchive/Voufo, Zalewski, Lumsdaine/Proceedings of the 10th ACM SIGPLAN workshop on Generic programming - WGP '14/Voufo, Zalewski, Lumsdaine - 2014 - Scoping rules on a platter.pdf:pdf},
isbn = {9781450330428},
journal = {Proceedings of the 10th ACM SIGPLAN workshop on Generic programming - WGP '14},
keywords = {c,combinators,concepts,name binding,name lookup,name resolution,scoping rules},
pages = {59--70},
publisher = {ACM Press},
title = {{Scoping rules on a platter}},
url = {http://dl.acm.org/citation.cfm?doid=2633628.2633633},
volume = {2},
year = {2014}
}
@article{Gibbons2014,
author = {Gibbons, Jeremy and Hinze, Ralf and Wu, Nicolas},
file = {:Users/matt/Documents/paperarchive/Gibbons, Hinze, Wu/Unknown/Gibbons, Hinze, Wu - 2014 - Conjugate Hylomorphisms ‚or The Mother of All Structured Recursion Schemes.pdf:pdf},
keywords = {a base functor f,adjunctions,algebras and final coalgebras,categorically,hylomorphisms,in which in and,initiality and finality,out are initial,recursion schemes,respectively,schemes arise from constructions,these recursion,which are shaped by},
pages = {1--12},
title = {{Conjugate Hylomorphisms ‚or: The Mother of All Structured Recursion Schemes}},
url = {https://web.comlab.ox.ac.uk/publications/publication8837-abstract.html},
year = {2014}
}
@article{Kiselyov2008,
address = {New York, New York, USA},
author = {Kiselyov, Oleg and Shan, Chung-chieh},
doi = {10.1145/1411286.1411288},
file = {:Users/matt/Documents/paperarchive/Kiselyov, Shan/Proceedings of the first ACM SIGPLAN symposium on Haskell - Haskell '08/Kiselyov, Shan - 2008 - Lightweight monadic regions.pdf:pdf},
isbn = {9781605580647},
journal = {Proceedings of the first ACM SIGPLAN symposium on Haskell - Haskell '08},
keywords = {deallocated exactly once,each resource should be,effect systems,is allocated and before,it is deallocated,management,monads,no,parametric polymorphism,regions,resource,second,soon after it is,subtyping,type classes,type systems,used only after it},
pages = {1},
publisher = {ACM Press},
title = {{Lightweight monadic regions}},
url = {http://portal.acm.org/citation.cfm?doid=1411286.1411288},
year = {2008}
}
@incollection{Ryder2005,
author = {Ryder, Chris and Thompson, Simon},
booktitle = {Trends in Functional Progamming},
file = {:Users/matt/Documents/paperarchive/Ryder, Thompson/Trends in Functional Progamming/Ryder, Thompson - 2005 - Software Metrics Measuring Haskell.pdf:pdf},
pages = {31--46},
title = {{Software Metrics : Measuring Haskell}},
year = {2005}
}
@article{Hinze2008,
abstract = {Abstract Streams, infinite sequences of elements, live in a coworld: they are given by a coinductive data type, operations on streams are implemented by corecursive programs, and proofs are conducted using coinduction. But there is more to it: suitably restricted, ... $\backslash$n},
author = {Hinze, R},
doi = {10.1145/1411204.1411232},
isbn = {9781595939197},
issn = {03621340},
journal = {Icfp'08},
keywords = {coinduction,finite calculus,generating functions,recurrences,streams,unique fixed points},
pages = {189--200},
title = {{Functional pearl: streams and unique fixed points}},
url = {http://dl.acm.org/citation.cfm?id=1411232$\backslash$npapers://cff96cb1-96b7-4b11-a3e3-f4947c1d45b9/Paper/p7373},
year = {2008}
}
@phdthesis{Li2006Thesis,
author = {Li, Huiqing},
file = {:Users/matt/Documents/paperarchive/Li/Unknown/Li - 2006 - Refactoring Haskell Programs.pdf:pdf},
keywords = {QA 76 Software,computer programming},
number = {September},
title = {{Refactoring Haskell Programs}},
url = {http://kar.kent.ac.uk/14425/},
year = {2006}
}
@article{McBride2014,
address = {New York, New York, USA},
author = {McBride, Conor Thomas},
doi = {10.1145/2628136.2628163},
file = {:Users/matt/Documents/paperarchive/McBride/Proceedings of the 19th ACM SIGPLAN international conference on Functional programming - ICFP '14/McBride - 2014 - How to keep your neighbours in order.pdf:pdf},
isbn = {9781450328739},
journal = {Proceedings of the 19th ACM SIGPLAN international conference on Functional programming - ICFP '14},
keywords = {2-3 trees,a precise implementation of,agda,balancing,dependent types,i take the time,insertion and deletion for,ordering,reporting a selection of,sorting,space,to explore the design},
pages = {297--309},
publisher = {ACM Press},
title = {{How to keep your neighbours in order}},
url = {http://dl.acm.org/citation.cfm?doid=2628136.2628163},
year = {2014}
}
@article{Gibbons2007,
address = {Berlin, Heidelberg},
author = {Gibbons, Jeremy},
doi = {10.1007/978-3-540-76786-2},
editor = {Backhouse, Roland and Gibbons, Jeremy and Hinze, Ralf and Jeuring, Johan},
file = {:Users/matt/Documents/paperarchive/Gibbons/Unknown/Gibbons - 2007 - Datatype-Generic Programming.pdf:pdf},
isbn = {978-3-540-76785-5},
publisher = {Springer Berlin Heidelberg},
series = {Lecture Notes in Computer Science},
title = {{Datatype-Generic Programming}},
url = {http://www.springerlink.com/index/10.1007/978-3-540-76786-2},
volume = {4719},
year = {2007}
}
@article{Bird2006,
author = {Bird, Richard S.},
doi = {10.1007/11783596{\_}9},
file = {:Users/matt/Documents/paperarchive/Bird/Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)/Bird - 2006 - Loopless functional algorithms.pdf:pdf},
isbn = {3540356312},
issn = {03029743},
journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
pages = {90--114},
title = {{Loopless functional algorithms}},
volume = {4014 LNCS},
year = {2006}
}
@article{Hinze2012,
address = {New York, New York, USA},
author = {Hinze, Ralf and James, Daniel W.H. and Harper, Thomas and Wu, Nicolas and Magalh{\~{a}}es, Jos{\'{e}} Pedro},
doi = {10.1145/2364394.2364405},
file = {:Users/matt/Documents/paperarchive/Hinze et al/Proceedings of the 8th ACM SIGPLAN workshop on Generic programming - WGP '12/Hinze et al. - 2012 - Sorting with bialgebras and distributive laws.pdf:pdf},
isbn = {9781450315760},
journal = {Proceedings of the 8th ACM SIGPLAN workshop on Generic programming - WGP '12},
pages = {69},
publisher = {ACM Press},
title = {{Sorting with bialgebras and distributive laws}},
url = {http://dl.acm.org/citation.cfm?doid=2364394.2364405},
year = {2012}
}
@article{Yorgey2010,
address = {New York, New York, USA},
author = {Yorgey, Brent a.},
doi = {10.1145/1863523.1863542},
file = {:Users/matt/Documents/paperarchive/Yorgey/Proceedings of the third ACM Haskell symposium on Haskell - Haskell '10/Yorgey - 2010 - Species and functors and types, oh my!.pdf:pdf},
isbn = {9781450302524},
journal = {Proceedings of the third ACM Haskell symposium on Haskell - Haskell '10},
pages = {147},
publisher = {ACM Press},
title = {{Species and functors and types, oh my!}},
url = {http://portal.acm.org/citation.cfm?doid=1863523.1863542},
volume = {2},
year = {2010}
}
@article{Kiselyov2004,
address = {New York, New York, USA},
author = {Kiselyov, Oleg and L{\"{a}}mmel, Ralf and Schupke, Keean},
doi = {10.1145/1017472.1017488},
file = {:Users/matt/Documents/paperarchive/Kiselyov, L{\"{a}}mmel, Schupke/Proceedings of the ACM SIGPLAN workshop on Haskell - Haskell '04/Kiselyov, L{\"{a}}mmel, Schupke - 2004 - Strongly typed heterogeneous collections.pdf:pdf},
isbn = {1581138504},
journal = {Proceedings of the ACM SIGPLAN workshop on Haskell - Haskell '04},
keywords = {cess,collections,dependently typed programming,equality,extensible records,haskell,type,type improvement,type-indexed rows,type-safe database ac-},
pages = {96},
publisher = {ACM Press},
title = {{Strongly typed heterogeneous collections}},
url = {http://portal.acm.org/citation.cfm?doid=1017472.1017488},
year = {2004}
}
@article{Orchard,
author = {Orchard, Dominic},
file = {:Users/matt/Documents/paperarchive/Orchard/Unknown/Orchard - Unknown - Should I use a Monad or a Comonad.pdf:pdf},
keywords = {comonad},
mendeley-tags = {comonad},
title = {{Should I use a Monad or a Comonad?}},
url = {http://www.cl.cam.ac.uk/{~}dao29/drafts/monad-or-comonad-orchard11-draft.pdf}
}
@article{Swierstra2008,
author = {Swierstra, Wouter},
doi = {10.1017/S0956796808006758},
file = {:Users/matt/Documents/paperarchive/Swierstra/Journal of Functional Programming/Swierstra - 2008 - Data types {\`{a}} la carte.pdf:pdf},
issn = {0956-7968},
journal = {Journal of Functional Programming},
month = {mar},
number = {04},
pages = {423--436},
title = {{Data types {\`{a}} la carte}},
url = {http://www.journals.cambridge.org/abstract{\_}S0956796808006758},
volume = {18},
year = {2008}
}
@article{Friedman2008,
abstract = {This is an expository introduction to simplicial sets and simplicial homotopy theory with particular focus on relating the combinatorial aspects of the theory to their geometric/topological origins. It is intended to be accessible to students familiar with just the fundamentals of algebraic topology.},
archivePrefix = {arXiv},
arxivId = {0809.4221},
author = {Friedman, Greg},
eprint = {0809.4221},
file = {:Users/matt/Documents/paperarchive/Friedman/Unknown/Friedman - 2008 - An elementary illustrated introduction to simplicial sets.pdf:pdf},
keywords = {simplicial homotopy,simplicial sets},
month = {sep},
pages = {57},
title = {{An elementary illustrated introduction to simplicial sets}},
url = {http://arxiv.org/abs/0809.4221},
year = {2008}
}
@article{Hansen2013,
abstract = {What factors impact the comprehensibility of code? Previous research suggests that expectation-congruent programs should take less time to understand and be less prone to errors. We present an experiment in which participants with programming experience predict the exact output of ten small Python programs. We use subtle differences between program versions to demonstrate that seemingly insignificant notational changes can have profound effects on correctness and response times. Our results show that experience increases performance in most cases, but may hurt performance significantly when underlying assumptions about related code statements are violated.},
archivePrefix = {arXiv},
arxivId = {1304.5257},
author = {Hansen, Michael and Goldstone, Robert L. and Lumsdaine, Andrew},
eprint = {1304.5257},
file = {:Users/matt/Documents/paperarchive/Hansen, Goldstone, Lumsdaine/Unknown/Hansen, Goldstone, Lumsdaine - 2013 - What Makes Code Hard to Understand.pdf:pdf},
keywords = {code complexity,program comprehension,psychology of programming},
month = {apr},
number = {Cc},
pages = {19},
title = {{What Makes Code Hard to Understand?}},
url = {http://arxiv.org/abs/1304.5257},
year = {2013}
}
@article{Ahn2000,
author = {Ahn, Sohyun and Riccio, Antonella and Ginty, David D},
file = {:Users/matt/Documents/paperarchive/Ahn, Riccio, Ginty/Unknown/Ahn, Riccio, Ginty - 2000 - S Patial C Onsiderations for S Timulus - D Ependent T Ranscription in N Eurons.pdf:pdf},
keywords = {abstract most neurons have,as an axon emanating,cell body,considerable distance from the,creb,elaborate dendrites as well,from the cell body,glutamate,may be located a,ngf,signal transduction,such complex and impres-,target cells,that form synaptic connections,transcription,which,with one or many},
number = {June},
title = {{S Patial C Onsiderations for S Timulus - D Ependent T Ranscription in N Eurons}},
year = {2000}
}
@article{Yorgey2014,
author = {Yorgey, Brent Abraham and Weirich, Stephanie},
file = {:Users/matt/Documents/paperarchive/Yorgey, Weirich/Unknown/Yorgey, Weirich - 2014 - Combinatorial Species and Labelled Structures.pdf:pdf},
title = {{Combinatorial Species and Labelled Structures}},
year = {2014}
}
@article{Collinson2006,
author = {Collinson, Matthew and Pym, David},
doi = {10.1016/j.entcs.2006.04.010},
file = {:Users/matt/Documents/paperarchive/Collinson, Pym/Electronic Notes in Theoretical Computer Science/Collinson, Pym - 2006 - Bunching for Regions and Locations.pdf:pdf},
issn = {15710661},
journal = {Electronic Notes in Theoretical Computer Science},
keywords = {bunched implications,denotational semantics,location,logic of,polymorphism,reference,region,type},
month = {may},
pages = {171--197},
title = {{Bunching for Regions and Locations}},
url = {http://linkinghub.elsevier.com/retrieve/pii/S1571066106001642},
volume = {158},
year = {2006}
}
@article{Gibbons2002,
author = {Gibbons, Jeremy},
file = {:Users/matt/Documents/paperarchive/Gibbons/Algebraic and Coalgebraic Methods in the {\ldots}/Gibbons - 2002 - Calculating Functional Programs.pdf:pdf},
journal = {Algebraic and Coalgebraic Methods in the {\ldots}},
title = {{Calculating Functional Programs}},
url = {http://link.springer.com/chapter/10.1007/3-540-47797-7{\_}5},
year = {2002}
}
@article{Magalhaes,
author = {Magalh{\~{a}}es, Jos{\'{e}} Pedro},
file = {:Users/matt/Documents/paperarchive/Magalh{\~{a}}es/Unknown/Magalh{\~{a}}es - Unknown - Optimisation of Generic Programs through Inlining.pdf:pdf},
pages = {1--16},
title = {{Optimisation of Generic Programs through Inlining}}
}
@article{Meijer1991,
abstract = {We develop a calculus for lazy functional programming based on recursion operators associated wit data type definitions. For these operators we derive various algebraic laws that are useful in deriving and manipulating programs. We shall show that all example functions in Bird and Walder's "Introduction to Functional Programming" can be expressed using these operators.},
author = {Meijer, Erik and Fokkinga, Maarten and Paterson, Ross},
doi = {10.1007/3540543961{\_}7},
isbn = {0387543961},
journal = {Functional Programming Languages and Computer Architecture},
pages = {124--144},
title = {{Functional programming with bananas, lenses, envelopes and barbed wire}},
url = {http://link.springer.com/chapter/10.1007/3540543961{\_}7},
year = {1991}
}
@article{Kiselyov,
abstract = {We present a rational reconstruction of extensible effects, the re-cently proposed alternative to monad transformers, as the conflu-ence of efforts to make effectful computations compose. Free mon-ads and then extensible effects emerge from the straightforward term representation of an effectful computation, as more and more boilerplate is abstracted away. The generalization process further leads to freer monads, constructed without the Functor constraint. The continuation exposed in freer monads can then be represented as an efficient type-aligned data structure. The end result is the al-gorithmically efficient extensible effects library, which is not only more comprehensible but also faster than earlier implementations. As an illustration of the new library, we show three surpris-ingly simple applications: non-determinism with committed choice (LogicT), catching IO exceptions in the presence of other effects, and the semi-automatic management of file handles and other re-sources through monadic regions. We extensively use and promote the new sort of 'laziness', which underlies the left Kan extension: instead of performing an operation, keep its operands and pretend it is done.},
author = {Kiselyov, Oleg and Ishii, Hiromi},
file = {:Users/matt/Documents/paperarchive/Kiselyov, Ishii/Unknown/Kiselyov, Ishii - Unknown - Freer Monads, More Extensible Effects.pdf:pdf},
keywords = {F33 [Logics and Mean-ings of Programs],F33 [Logics and Meanings of Programs],Kan extension,Studies of Pro-gram Constructs—Control primitives,coroutine,effect handler,effect interaction,open union,type and effect system},
title = {{Freer Monads, More Extensible Effects}}
}
@article{Danvy1998,
author = {Danvy, Olivier},
doi = {10.1017/S0956796898003104},
file = {:Users/matt/Documents/paperarchive/Danvy/Journal of Functional Programming/Danvy - 1998 - Functional unparsing.pdf:pdf},
issn = {09567968},
journal = {Journal of Functional Programming},
month = {nov},
number = {6},
pages = {621--625},
title = {{Functional unparsing}},
url = {http://www.journals.cambridge.org/abstract{\_}S0956796898003104},
volume = {8},
year = {1998}
}
@article{Kiselyov2005,
address = {New York, New York, USA},
author = {Kiselyov, Oleg and Shan, Chung-chieh and Friedman, Daniel P. and Sabry, Amr},
doi = {10.1145/1086365.1086390},
file = {:Users/matt/Documents/paperarchive/Kiselyov et al/Proceedings of the tenth ACM SIGPLAN international conference on Functional programming - ICFP '05/Kiselyov et al. - 2005 - Backtracking, interleaving, and terminating monad transformers.pdf:pdf},
isbn = {1595930647},
journal = {Proceedings of the tenth ACM SIGPLAN international conference on Functional programming - ICFP '05},
keywords = {continuations,control delimiters,gramming,haskell,logic pro-,prolog,streams},
pages = {192},
publisher = {ACM Press},
title = {{Backtracking, interleaving, and terminating monad transformers}},
url = {http://portal.acm.org/citation.cfm?doid=1086365.1086390},
year = {2005}
}
@article{Nanevski2011,
author = {Nanevski, Aleksandar and Banerjee, Anindya and Garg, Deepak},
doi = {10.1109/SP.2011.12},
file = {:Users/matt/Documents/paperarchive/Nanevski, Banerjee, Garg/2011 IEEE Symposium on Security and Privacy/Nanevski, Banerjee, Garg - 2011 - Verification of Information Flow and Access Control Policies with Dependent Types.pdf:pdf},
isbn = {978-1-4577-0147-4},
journal = {2011 IEEE Symposium on Security and Privacy},
keywords = {-information flow,access control,type theory},
month = {may},
number = {c},
pages = {165--179},
publisher = {Ieee},
title = {{Verification of Information Flow and Access Control Policies with Dependent Types}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=5958028},
year = {2011}
}
@inproceedings{Gibbons2014b,
abstract = {A domain-specific language can be implemented by embedding within a general-purpose host language. This embedding may be deep or shallow, depending on whether terms in the language construct syntactic or semantic representations. The deep and shallow styles are closely related, and intimately connected to folds; in this paper, we explore that connection.},
author = {Gibbons, Jeremy and Wu, Nicolas},
booktitle = {Proceedings of the 19th ACM SIGPLAN international conference on Functional programming - ICFP '14},
doi = {10.1145/2628136.2628138},
isbn = {9781450328739},
pages = {339--347},
publisher = {ACM Press},
title = {{Folding domain-specific languages}},
url = {http://dl.acm.org/citation.cfm?doid=2628136.2628138},
year = {2014}
}
@article{Meyerovich2013,
abstract = {Some programming languages become widely popular while others fail to grow beyond their niche or disappear altogether. This paper uses survey methodology to identify the factors that lead to language adoption. We analyze large datasets, including over 200,000 SourceForge projects, 590,000 projects tracked by Ohloh, and multiple surveys of 1,000-13,000 programmers. We report several prominent findings. First, language adoption follows a power law; a small number of languages account for most language use, but the programming market supports many languages with niche user bases. Second, intrinsic features have only secondary importance in adoption. Open source libraries, existing code, and experience strongly influence developers when selecting a language for a project. Language features such as performance, reliability, and simple semantics do not. Third, developers will steadily learn and forget languages. The overall number of languages developers are familiar with is independent of age. Finally, when considering intrinsic aspects of languages, developers prioritize expressivity over correctness. They perceive static types as primarily helping with the latter, hence partly explaining the popularity of dynamic languages.},
author = {Meyerovich, Leo a and Rabkin, Ariel},
doi = {10.1145/2509136.2509515},
file = {:Users/matt/Documents/paperarchive/Meyerovich, Rabkin/OOPSLA'13 - roceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages {\&} applications/Meyerovich, Rabkin - 2013 - Empirical Analysis of Programming Language Adoption.pdf:pdf},
isbn = {9781450323741},
issn = {0362-1340},
journal = {OOPSLA'13 - roceedings of the 2013 ACM SIGPLAN international conference on Object oriented programming systems languages {\&} applications},
number = {Section 7},
pages = {1--18},
title = {{Empirical Analysis of Programming Language Adoption}},
url = {http://dl.acm.org/citation.cfm?id=2509515},
year = {2013}
}
@article{Pearl,
author = {Pearl, Functional and Fischer, Sebastian and Hu, Zhenjiang and Pacheco, Hugo},
file = {:Users/matt/Documents/paperarchive/Pearl et al/Unknown/Pearl et al. - Unknown - A clear picture of lens laws.pdf:pdf},
title = {{A clear picture of lens laws}}
}
@article{Plotkin2009,
abstract = {We present an algebraic treatment of exception handlers and, more generally, introduce handlers for other computational effects representable by an algebraic theory. These include nondeterminism, interactive input/output, concurrency, state, time, and their combinations; in all cases the computation monad is the free-model monad of the theory. Each such handler corresponds to a model of the theory for the effects at hand. The handling construct, which applies a handler to a computation, is based on the one introduced by Benton and Kennedy, and is interpreted using the homomorphism induced by the universal property of the free model. This general construct can be used to describe previously unrelated concepts from both theory and practice.},
author = {Plotkin, Gordon and Pretnar, Matija},
file = {:Users/matt/Documents/paperarchive/Plotkin, Pretnar/Programming Languages and Systems/Plotkin, Pretnar - 2009 - Handlers of algebraic effects.pdf:pdf},
journal = {Programming Languages and Systems},
pages = {80--94},
title = {{Handlers of algebraic effects}},
url = {http://link.springer.com/chapter/10.1007/978-3-642-00590-9{\_}7},
volume = {5502},
year = {2009}
}
@article{Fredriksson2014,
address = {New York, New York, USA},
author = {Fredriksson, Olle and Ghica, Dan R.},
doi = {10.1145/2628136.2628152},
file = {:Users/matt/Documents/paperarchive/Fredriksson, Ghica/Proceedings of the 19th ACM SIGPLAN international conference on Functional programming - ICFP '14/Fredriksson, Ghica - 2014 - Krivine nets.pdf:pdf},
isbn = {9781450328739},
journal = {Proceedings of the 19th ACM SIGPLAN international conference on Functional programming - ICFP '14},
keywords = {abstract machines,distributed execution,simulation},
pages = {349--361},
publisher = {ACM Press},
title = {{Krivine nets}},
url = {http://dl.acm.org/citation.cfm?doid=2628136.2628152},
year = {2014}
}
@article{Bird1984,
abstract = {This paper describes a technique for transforming functional programs that repeatedly traverse a data structure into more efficient alternatives that do not. The transformation makes essential use of lazy evaluation and local recursion (such as provided by letrec, or its equivalent) to build a circular program that, on one pass over the structure, determines the effects of the individual traversals and then combines them.},
author = {Bird, R. S.},
doi = {10.1007/BF00264249},
file = {:Users/matt/Documents/paperarchive/Bird/Acta Informatica/Bird - 1984 - Using circular programs to eliminate multiple traversals of data.pdf:pdf},
issn = {00015903},
journal = {Acta Informatica},
pages = {239--250},
title = {{Using circular programs to eliminate multiple traversals of data}},
volume = {21},
year = {1984}
}
@article{Chapman2010,
address = {New York, New York, USA},
author = {Chapman, James and Dagand, Pierre-{\'{E}}variste and McBride, Conor and Morris, Peter},
doi = {10.1145/1863543.1863547},
file = {:Users/matt/Documents/paperarchive/Chapman et al/Proceedings of the 15th ACM SIGPLAN international conference on Functional programming - ICFP '10/Chapman et al. - 2010 - The gentle art of levitation.pdf:pdf},
isbn = {9781605587943},
journal = {Proceedings of the 15th ACM SIGPLAN international conference on Functional programming - ICFP '10},
pages = {3},
publisher = {ACM Press},
title = {{The gentle art of levitation}},
url = {http://portal.acm.org/citation.cfm?doid=1863543.1863547},
year = {2010}
}
@article{Gill2009,
address = {New York, New York, USA},
author = {Gill, Andy},
doi = {10.1145/1596638.1596653},
file = {:Users/matt/Documents/paperarchive/Gill/Proceedings of the 2nd ACM SIGPLAN symposium on Haskell - Haskell '09/Gill - 2009 - Type-safe observable sharing in Haskell.pdf:pdf},
isbn = {9781605585086},
journal = {Proceedings of the 2nd ACM SIGPLAN symposium on Haskell - Haskell '09},
keywords = {a direct and principled,a graph representation in,a type-safe graph detection,constructor classes and type,dsl compilation,families to provide,makes good use of,mechanism,observable sharing,the solution,way},
pages = {117},
publisher = {ACM Press},
title = {{Type-safe observable sharing in Haskell}},
url = {http://portal.acm.org/citation.cfm?doid=1596638.1596653},
year = {2009}
}
@article{Rivas2014a,
abstract = {There are different notions of computation, the most popular being monads, applicative functors, and arrows. In this article we show that these three notions can be seen as monoids in a monoidal category. We demonstrate that at this level of abstraction one can obtain useful results which can be instantiated to the different notions of computation. In particular, we show how free constructions and Cayley representations for monoids translate into useful constructions for monads, applicative functors, and arrows. Moreover, the uniform presentation of all three notions helps in the analysis of the relation between them.},
archivePrefix = {arXiv},
arxivId = {1406.4823},
author = {Rivas, Exequiel and Jaskelioff, Mauro},
eprint = {1406.4823},
file = {:Users/matt/Documents/paperarchive/Rivas, Jaskelioff/arXiv.org/Rivas, Jaskelioff - 2014 - Notions of Computation as Monoids.pdf:pdf},
journal = {arXiv.org},
number = {June},
title = {{Notions of Computation as Monoids}},
url = {http://arxiv.org/abs/1406.4823v1$\backslash$npapers2://publication/uuid/5A24518A-753F-4A7F-98A6-07A9450D4A45},
volume = {cs.LO},
year = {2014}
}
@techreport{Thompson2001,
author = {Thompson, Simon and Reinke, Claus},
booktitle = {Advanced Functional Programming},
file = {:Users/matt/Documents/paperarchive/Thompson, Reinke/Advanced Functional Programming/Thompson, Reinke - 2001 - Refactoring functional programs.pdf:pdf},
pages = {1--6},
title = {{Refactoring functional programs}},
url = {http://link.springer.com/chapter/10.1007/11546382{\_}9},
year = {2001}
}
@article{Jacobs2009,
author = {Jacobs, Bart and Heunen, Chris and Hasuo, Ichiro},
doi = {10.1017/S0956796809007308},
file = {:Users/matt/Documents/paperarchive/Jacobs, Heunen, Hasuo/Journal of Functional Programming/Jacobs, Heunen, Hasuo - 2009 - Categorical semantics for arrows.pdf:pdf},
issn = {0956-7968},
journal = {Journal of Functional Programming},
month = {jun},
number = {3-4},
pages = {403},
title = {{Categorical semantics for arrows}},
url = {http://www.journals.cambridge.org/abstract{\_}S0956796809007308},
volume = {19},
year = {2009}
}
@article{Jaskelioff2012,
abstract = {Traversals of data structures are ubiquitous in programming. Consequently, it is important to be able to characterise those structures that are traversable and understand their algebraic properties. Traversable functors have been characterised by McBride and Paterson as those equipped with a distributive law over arbitrary applicative functors; however, laws that fully capture the intuition behind traversals are missing. This article is an attempt to remedy this situation by proposing laws for characterising traversals that capture the intuition behind them. To support our claims, we prove that finitary containers are traversable in our sense and argue that elements in a traversable structure are visited exactly once.},
archivePrefix = {arXiv},
arxivId = {1202.2919},
author = {Jaskelioff, Mauro and Rypacek, Ondrej},
doi = {10.4204/EPTCS.76.5},
eprint = {1202.2919},
file = {:Users/matt/Documents/paperarchive/Jaskelioff, Rypacek/Electronic Proceedings in Theoretical Computer Science/Jaskelioff, Rypacek - 2012 - An Investigation of the Laws of Traversals.pdf:pdf},
issn = {2075-2180},
journal = {Electronic Proceedings in Theoretical Computer Science},
number = {Msfp},
pages = {40--49},
title = {{An Investigation of the Laws of Traversals}},
volume = {76},
year = {2012}
}
@article{Johnson2013,
author = {Gibbons, Jeremy and Johnson, Michael},
file = {:Users/matt/Documents/paperarchive/Gibbons, Johnson/Unknown/Gibbons, Johnson - 2013 - Relating Algebraic and Coalgebraic Descriptions of Lenses.pdf:pdf},
title = {{Relating Algebraic and Coalgebraic Descriptions of Lenses}},
volume = {XX},
year = {2013}
}
@article{Weirich2010,
author = {Weirich, Stephanie and Casinghino, Chris},
doi = {10.1145/1816027.1816036},
file = {:Users/matt/Documents/paperarchive/Weirich, Casinghino/ACM SIGPLAN Notices/Weirich, Casinghino - 2010 - Arity-generic datatype-generic programming.pdf:pdf},
isbn = {9781605588902},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
keywords = {agda,arity-generic programming,dependent types},
month = {jun},
number = {11},
pages = {7},
title = {{Arity-generic datatype-generic programming}},
url = {http://portal.acm.org/citation.cfm?doid=1816027.1816036},
volume = {44},
year = {2010}
}
@article{Gibbons2009,
author = {Gibbons, Jeremy and Oliveira, Bruno C. D. S.},
doi = {10.1017/S0956796809007291},
file = {:Users/matt/Documents/paperarchive/Gibbons, Oliveira/Journal of Functional Programming/Gibbons, Oliveira - 2009 - The essence of the Iterator pattern.pdf:pdf},
issn = {0956-7968},
journal = {Journal of Functional Programming},
keywords = {design pattern,fold,idiom,iterator,map,monad,traversal},
month = {jun},
number = {3-4},
pages = {377},
title = {{The essence of the Iterator pattern}},
url = {http://www.journals.cambridge.org/abstract{\_}S0956796809007291},
volume = {19},
year = {2009}
}
@article{Atkey2009,
abstract = {Moggi’s Computational Monads and Power et al’s equivalent notion of Freyd category have captured a large range of computational effects present in programming languages. Exam- ples include non-termination, non-determinism, exceptions, continuations, side-effects and input/output. We present generalisations of both computational monads and Freyd cate- gories, which we call parameterised monads and parameterised Freyd categories, that also capture computational effects with parameters. Examples of such are composable contin- uations, side-effects where the type of the state varies and input/output where the range of inputs and outputs varies. By also considering structured parameterisation, we extend the range of effects to cover separated side-effects and multiple independent streams of I/O.We also present two typed $\lambda$-calculi that soundly and completely model our categor- ical definitions — with and without symmetric monoidal parameterisation — and act as prototypical languages with parameterised effects.},
author = {Atkey, Robert},
doi = {10.1017/S095679680900728X},
file = {:Users/matt/Documents/paperarchive/Atkey/Journal of Functional Programming/Atkey - 2009 - Parameterised notions of computation.pdf:pdf},
issn = {0956-7968},
journal = {Journal of Functional Programming},
pages = {335},
title = {{Parameterised notions of computation}},
volume = {19},
year = {2009}
}
@article{Hofer2008,
address = {New York, New York, USA},
author = {Hofer, Christian and Ostermann, Klaus and Rendel, Tillmann and Moors, Adriaan},
doi = {10.1145/1449913.1449935},
file = {:Users/matt/Documents/paperarchive/Hofer et al/Proceedings of the 7th international conference on Generative programming and component engineering - GPCE '08/Hofer et al. - 2008 - Polymorphic embedding of dsls.pdf:pdf},
isbn = {9781605582672},
journal = {Proceedings of the 7th international conference on Generative programming and component engineering - GPCE '08},
keywords = {13,27,algebraic semantics,are,but domain-specific optimizations or,compositionality,domain-specific,extensibility,have been proposed,languages,other kinds of analyses,pure embedding,scala,tion and multi-staged computation},
pages = {137},
publisher = {ACM Press},
title = {{Polymorphic embedding of dsls}},
url = {http://portal.acm.org/citation.cfm?doid=1449913.1449935},
year = {2008}
}
@article{Asada2010,
address = {New York, New York, USA},
author = {Asada, Kazuyuki},
doi = {10.1145/1863597.1863607},
file = {:Users/matt/Documents/paperarchive/Asada/Proceedings of the third ACM SIGPLAN workshop on Mathematically structured functional programming - MSFP '10/Asada - 2010 - Arrows are strong monads.pdf:pdf},
isbn = {9781450302555},
journal = {Proceedings of the third ACM SIGPLAN workshop on Mathematically structured functional programming - MSFP '10},
keywords = {arrow,computational,freyd category,strong monad},
pages = {33},
publisher = {ACM Press},
title = {{Arrows are strong monads}},
url = {http://portal.acm.org/citation.cfm?doid=1863597.1863607},
year = {2010}
}
@article{Thompson2013,
author = {Thompson, Simon and Li, Huiqing},
doi = {10.1017/S0956796813000117},
file = {:Users/matt/Documents/paperarchive/Thompson, Li/Journal of Functional Programming/Thompson, Li - 2013 - Refactoring tools for functional languages.pdf:pdf},
issn = {0956-7968},
journal = {Journal of Functional Programming},
month = {oct},
number = {03},
pages = {293--350},
title = {{Refactoring tools for functional languages}},
url = {http://www.journals.cambridge.org/abstract{\_}S0956796813000117},
volume = {23},
year = {2013}
}
@article{MHill2012,
abstract = {Much of what we know about how programmers refactor in the wild is based on studies that examine just a few software projects. Researchers have rarely taken the time to replicate these studies in other contexts or to examine the assumptions on which they are based. To help put refactoring research on a sound scientific basis, we draw conclusions using four data sets spanning more than 13 000 developers, 240 000 tool-assisted refactorings, 2500 developer hours, and 3400 version control commits. Using these data, we cast doubt on several previously stated assumptions about how programmers refactor, while validating others. For example, we find that programmers frequently do not indicate refactoring activity in commit logs, which contradicts assumptions made by several previous researchers. In contrast, we were able to confirm the assumption that programmers do frequently intersperse refactoring with other program changes. By confirming assumptions and replicating studies made by other researchers, we can have greater confidence that those researchers' conclusions are generalizable.},
author = {Murphy-Hill, Emerson and Parnin, Chris and Black, Andrew P},
doi = {10.1109/TSE.2011.41},
file = {:Users/matt/Documents/paperarchive/Murphy-Hill, Parnin, Black/IEEE Transactions on Software Engineering/Murphy-Hill, Parnin, Black - 2012 - How we refactor, and how we know it.pdf:pdf},
isbn = {9781424434527},
issn = {00985589},
journal = {IEEE Transactions on Software Engineering},
keywords = {Refactoring,floss refactoring,refactoring tools,root-canal refactoring},
pages = {5--18},
title = {{How we refactor, and how we know it}},
url = {http://www.citeulike.org/user/emerson/article/5400371},
volume = {38},
year = {2012}
}
@article{Paterson2001,
address = {New York, New York, USA},
author = {Paterson, Ross},
doi = {10.1145/507663.507664},
file = {:Users/matt/Documents/paperarchive/Paterson/Proceedings of the sixth ACM SIGPLAN international conference on Functional programming - ICFP '01/Paterson - 2001 - A new notation for arrows.pdf:pdf},
isbn = {1581134150},
journal = {Proceedings of the sixth ACM SIGPLAN international conference on Functional programming - ICFP '01},
pages = {229},
publisher = {ACM Press},
title = {{A new notation for arrows}},
url = {http://portal.acm.org/citation.cfm?doid=507635.507664},
year = {2001}
}
@article{Wu2014,
address = {New York, New York, USA},
author = {Wu, Nicolas and Schrijvers, Tom and Hinze, Ralf},
doi = {10.1145/2633357.2633358},
file = {:Users/matt/Documents/paperarchive/Wu, Schrijvers, Hinze/Proceedings of the 2014 ACM SIGPLAN symposium on Haskell - Haskell '14/Wu, Schrijvers, Hinze - 2014 - Effect handlers in scope.pdf:pdf},
isbn = {9781450330411},
journal = {Proceedings of the 2014 ACM SIGPLAN symposium on Haskell - Haskell '14},
pages = {1--12},
publisher = {ACM Press},
title = {{Effect handlers in scope}},
url = {http://dl.acm.org/citation.cfm?doid=2633357.2633358},
year = {2014}
}
@article{Johnson2012,
author = {Johnson, Michael and Rosebrugh, Robert and Wood, R. J.},
doi = {10.1017/S0960129511000442},
file = {:Users/matt/Documents/paperarchive/Johnson, Rosebrugh, Wood/Mathematical Structures in Computer Science/Johnson, Rosebrugh, Wood - 2012 - Lenses, fibrations and universal translations.pdf:pdf},
issn = {0960-1295},
journal = {Mathematical Structures in Computer Science},
pages = {25--42},
title = {{Lenses, fibrations and universal translations}},
volume = {22},
year = {2012}
}
@article{Vazou2014,
address = {New York, New York, USA},
author = {Vazou, Niki and Seidel, Eric L. and Jhala, Ranjit and Vytiniotis, Dimitrios and Peyton-Jones, Simon},
doi = {10.1145/2628136.2628161},
file = {:Users/matt/Documents/paperarchive/Vazou et al/Proceedings of the 19th ACM SIGPLAN international conference on Functional programming - ICFP '14/Vazou et al. - 2014 - Refinement types for Haskell.pdf:pdf},
isbn = {9781450328739},
journal = {Proceedings of the 19th ACM SIGPLAN international conference on Functional programming - ICFP '14},
pages = {269--282},
publisher = {ACM Press},
title = {{Refinement types for Haskell}},
url = {http://dl.acm.org/citation.cfm?doid=2628136.2628161},
year = {2014}
}
@article{Hughes2003,
author = {Hughes, R. John M. and Swierstra, S. Doaitse},
doi = {10.1145/944746.944727},
file = {:Users/matt/Documents/paperarchive/Hughes, Swierstra/ACM SIGPLAN Notices/Hughes, Swierstra - 2003 - Polish parsers, step by step.pdf:pdf},
isbn = {1581137567},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
keywords = {ambiguous grammars,breadth-first search,glr parsing,online results,parser combinators,polish representa-,tion},
month = {sep},
number = {9},
pages = {239--248},
title = {{Polish parsers, step by step}},
url = {http://portal.acm.org/citation.cfm?doid=944746.944727},
volume = {38},
year = {2003}
}
@article{Elliott2009,
address = {New York, New York, USA},
author = {Elliott, Conal M.},
doi = {10.1145/1596638.1596643},
file = {:Users/matt/Documents/paperarchive/Elliott/Proceedings of the 2nd ACM SIGPLAN symposium on Haskell - Haskell '09/Elliott - 2009 - Push-pull functional reactive programming.pdf:pdf},
isbn = {9781605585086},
journal = {Proceedings of the 2nd ACM SIGPLAN symposium on Haskell - Haskell '09},
keywords = {a finite,because they can be,before being clipped to,concur-,data-driven,demand-driven,finite counterparts,functional reactive programming,more composable than their,or space,rency,scaled arbitrarily in time,semantics},
pages = {25},
publisher = {ACM Press},
title = {{Push-pull functional reactive programming}},
url = {http://portal.acm.org/citation.cfm?doid=1596638.1596643},
year = {2009}
}
@article{Bahr2012b,
author = {Bahr, Patrick and Hvitved, Tom},
doi = {10.4204/EPTCS.76.3},
file = {:Users/matt/Documents/paperarchive/Bahr, Hvitved/Electronic Proceedings in Theoretical Computer Science/Bahr, Hvitved - 2012 - Parametric Compositional Data Types.pdf:pdf},
issn = {2075-2180},
journal = {Electronic Proceedings in Theoretical Computer Science},
month = {feb},
number = {Msfp},
pages = {3--24},
title = {{Parametric Compositional Data Types}},
url = {http://arxiv.org/abs/1202.2917v1},
volume = {76},
year = {2012}
}
@article{Orcharda,
author = {Orchard, Dominic},
file = {:Users/matt/Documents/paperarchive/Orchard/Unknown/Orchard - Unknown - A Notion for Comonads.pdf:pdf},
keywords = {comonad},
mendeley-tags = {comonad},
title = {{A Notion for Comonads}},
url = {http://www.cl.cam.ac.uk/{~}dao29/publ/codo-notation-orchard-ifl12.pdf}
}
@inproceedings{Hallgren2004,
author = {Hallgren, Thomas and Jones, Mark P and Kieburtz, Richard B},
booktitle = {High Confidence Software and Systems Conference},
file = {:Users/matt/Documents/paperarchive/Hallgren, Jones, Kieburtz/High Confidence Software and Systems Conference/Hallgren, Jones, Kieburtz - 2004 - An Overview of the Programatica Toolset.pdf:pdf},
pages = {1--16},
title = {{An Overview of the Programatica Toolset}},
year = {2004}
}
@article{Cook2009,
author = {Cook, William R.},
doi = {10.1145/1639949.1640133},
file = {:Users/matt/Documents/paperarchive/Cook/ACM SIGPLAN Notices/Cook - 2009 - On understanding data abstraction, revisited.pdf:pdf},
isbn = {9781605587349},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
keywords = {abstract data type,adt,class,object},
month = {oct},
number = {10},
pages = {557},
title = {{On understanding data abstraction, revisited}},
url = {http://portal.acm.org/citation.cfm?doid=1639949.1640133},
volume = {44},
year = {2009}
}
@article{Adams2014,
address = {New York, New York, USA},
author = {Adams, Michael D. and Ağacan, {\"{O}}mer S.},
doi = {10.1145/2633357.2633369},
file = {:Users/matt/Documents/paperarchive/Adams, Ağacan/Proceedings of the 2014 ACM SIGPLAN symposium on Haskell - Haskell '14/Adams, Ağacan - 2014 - Indentation-sensitive parsing for Parsec.pdf:pdf},
isbn = {9781450330411},
journal = {Proceedings of the 2014 ACM SIGPLAN symposium on Haskell - Haskell '14},
pages = {121--132},
publisher = {ACM Press},
title = {{Indentation-sensitive parsing for Parsec}},
url = {http://dl.acm.org/citation.cfm?doid=2633357.2633369},
year = {2014}
}
@article{Eisenberg2014,
address = {New York, New York, USA},
author = {Eisenberg, Richard a. and Stolarek, Jan},
doi = {10.1145/2633357.2633361},
file = {:Users/matt/Documents/paperarchive/Eisenberg, Stolarek/Proceedings of the 2014 ACM SIGPLAN symposium on Haskell - Haskell '14/Eisenberg, Stolarek - 2014 - Promoting functions to type families in Haskell.pdf:pdf},
isbn = {9781450330411},
journal = {Proceedings of the 2014 ACM SIGPLAN symposium on Haskell - Haskell '14},
keywords = {defunctionalization,haskell,type-level programming},
pages = {95--106},
publisher = {ACM Press},
title = {{Promoting functions to type families in Haskell}},
url = {http://dl.acm.org/citation.cfm?doid=2633357.2633361},
year = {2014}
}
@article{Keuchel2014,
author = {Keuchel, Steven and Schrijvers, Tom},
file = {:Users/matt/Documents/paperarchive/Keuchel, Schrijvers/Unknown/Keuchel, Schrijvers - 2014 - Towards efficient implementations of effect handlers – Extended Abstract –.pdf:pdf},
isbn = {0897915984},
keywords = {delimited control,effect handlers,modularity,monads},
pages = {1--2},
title = {{Towards efficient implementations of effect handlers – Extended Abstract –}},
year = {2014}
}
@article{Snyder1993,
address = {New York, New York, USA},
author = {Snyder, John M. and Woodbury, Adam R. and Fleischer, Kurt and Currin, Bena and Barr, Alan H.},
doi = {10.1145/166117.166158},
file = {:Users/matt/Documents/paperarchive/Snyder et al/Proceedings of the 20th annual conference on Computer graphics and interactive techniques - SIGGRAPH '93/Snyder et al. - 1993 - Interval methods for multi-point collisions between time-dependent curved surfaces.pdf:pdf},
isbn = {0897916018},
journal = {Proceedings of the 20th annual conference on Computer graphics and interactive techniques - SIGGRAPH '93},
pages = {321--334},
publisher = {ACM Press},
title = {{Interval methods for multi-point collisions between time-dependent curved surfaces}},
url = {http://portal.acm.org/citation.cfm?doid=166117.166158},
year = {1993}
}
@article{Bird2003,
address = {New York, New York, USA},
author = {Bird, Richard and Hinze, Ralf},
doi = {10.1145/871895.871896},
file = {:Users/matt/Documents/paperarchive/Bird, Hinze/Proceedings of the ACM SIGPLAN workshop on Haskell - Haskell '03/Bird, Hinze - 2003 - Functional Pearl trouble shared is trouble halved.pdf:pdf},
isbn = {1581137583},
journal = {Proceedings of the ACM SIGPLAN workshop on Haskell - Haskell '03},
keywords = {binomial trees,boolean,haskell,lattices,memoization,purely functional data structures,sharing},
pages = {1--6},
publisher = {ACM Press},
title = {{Functional Pearl trouble shared is trouble halved}},
url = {http://portal.acm.org/citation.cfm?doid=871895.871896},
year = {2003}
}
@article{Gibbons2012,
abstract = {Lenses are a heavily studied form of bidirectional transformation with diverse applications including database view updating, software development and memory management. Recent work has explored lenses category theoretically, and established that the category of lenses for a fixed "view" V is, up to isomorphism, the category of algebras for a particular monad on Set/V. In this paper we show that in addition lenses are the coalgebras for the comonad generated by the cartesian closure adjunction on Set. We present a fully constructive proof of the coalgebra correspondence, we note that the algebra correspondence extends to arbitrary categories with products and that the coalgebra correspondence extends to arbitrary cartesian closed categories, and we show that both correspondences extend to isomorphisms of categories. The resulting isomorphism between a category of algebras and a category of coalgebras is unexpected, and we analyze it isolating its underlying generality, and also the particularity that restricts its applicability. We end with remarks about the utility of the two different treatments of lenses,especially for obtaining further, more realistic, generalizations of the notion of lens.},
author = {Gibbons, Jeremy and Johnson, Michael},
file = {:Users/matt/Documents/paperarchive/Gibbons, Johnson/Electronic Communications of the {\ldots}/Gibbons, Johnson - 2012 - Relating algebraic and coalgebraic descriptions of lenses.pdf:pdf},
journal = {Electronic Communications of the {\ldots}},
keywords = {algebra,coalgebra,comonads,lens,monads,view update},
title = {{Relating algebraic and coalgebraic descriptions of lenses}},
url = {http://journal.ub.tu-berlin.de/eceasst/article/view/726},
volume = {49},
year = {2012}
}
@article{Grabmayer2014,
address = {New York, New York, USA},
author = {Grabmayer, Clemens and Rochel, Jan},
doi = {10.1145/2628136.2628148},
file = {:Users/matt/Documents/paperarchive/Grabmayer, Rochel/Proceedings of the 19th ACM SIGPLAN international conference on Functional programming - ICFP '14/Grabmayer, Rochel - 2014 - Maximal sharing in the Lambda calculus with letrec.pdf:pdf},
isbn = {9781450328739},
journal = {Proceedings of the 19th ACM SIGPLAN international conference on Functional programming - ICFP '14},
keywords = {and it can be,cyclic definitions,higher-order term graphs,lambda calculus with letrec,languages,letrec,maximal sharing,subterm sharing,syntac-,the $\lambda$ -calculus with,tic core of these,unfolding semantics,viewed as their abstraction,$\lambda$ letrec forms a},
pages = {67--80},
publisher = {ACM Press},
title = {{Maximal sharing in the Lambda calculus with letrec}},
url = {http://dl.acm.org/citation.cfm?doid=2628136.2628148},
year = {2014}
}
@article{Montagu2013,
author = {Montagu, Benoit and Pierce, Benjamin C. and Pollack, Randy},
doi = {10.1109/CSF.2013.8},
file = {:Users/matt/Documents/paperarchive/Montagu, Pierce, Pollack/2013 IEEE 26th Computer Security Foundations Symposium/Montagu, Pierce, Pollack - 2013 - A Theory of Information-Flow Labels.pdf:pdf},
isbn = {978-0-7695-5031-2},
journal = {2013 IEEE 26th Computer Security Foundations Symposium},
keywords = {-security,decentralized label,design,difc,disjunction category model,dlm,flow control,flume,ifc,information,jif,label models,languages,lio,model,theory},
month = {jun},
pages = {3--17},
publisher = {Ieee},
title = {{A Theory of Information-Flow Labels}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=6595817},
year = {2013}
}
@article{Jaskelioff2014,
abstract = {Representation theorems relate seemingly complex objects to concrete, more tractable ones. In this paper, we take advantage of the abstraction power of category theory and provide a general representation theorem for a wide class of second-order functionals which are polymorphic over a class of functors. Types polymorphic over a class of functors are easily representable in languages such as Haskell, but are difficult to analyse and reason about. The concrete representation provided by the theorem is easier to analyse, but it might not be as convenient to implement. Therefore, depending on the task at hand, the change of representation may prove valuable in one direction or the other. We showcase the usefulness of the representation theorem with a range of examples. Concretely, we show how the representation theorem can be used to show that traversable functors are finitary containers, how parameterised coalgebras relate to very well-behaved lenses, and how algebraic effects might be implemented in a functional language.},
archivePrefix = {arXiv},
arxivId = {1402.1699},
author = {Jaskelioff, Mauro and O'Connor, Russell},
eprint = {1402.1699},
file = {:Users/matt/Documents/paperarchive/Jaskelioff, O'Connor/Unknown/Jaskelioff, O'Connor - 2014 - A Representation Theorem for Second-Order Functionals.pdf:pdf},
number = {February},
title = {{A Representation Theorem for Second-Order Functionals}},
url = {http://arxiv.org/abs/1402.1699},
year = {2014}
}
@article{Kaki2014,
address = {New York, New York, USA},
author = {Kaki, Gowtham and Jagannathan, Suresh},
doi = {10.1145/2628136.2628159},
file = {:Users/matt/Documents/paperarchive/Kaki, Jagannathan/Proceedings of the 19th ACM SIGPLAN international conference on Functional programming - ICFP '14/Kaki, Jagannathan - 2014 - A relational framework for higher-order shape analysis.pdf:pdf},
isbn = {9781450328739},
journal = {Proceedings of the 19th ACM SIGPLAN international conference on Functional programming - ICFP '14},
keywords = {decidability,dependent types,inductive relations,metric relations,para-,relational specifications,standard ml},
pages = {311--324},
publisher = {ACM Press},
title = {{A relational framework for higher-order shape analysis}},
url = {http://dl.acm.org/citation.cfm?doid=2628136.2628159},
year = {2014}
}
@article{Corecursion1998,
author = {Corecursion, Apomorphisms},
file = {:Users/matt/Documents/paperarchive/Corecursion/Unknown/Corecursion - 1998 - Functional Programming With.pdf:pdf},
keywords = {categorical program calculation,co,datatypes,functional programming,recursion forms,total,typed},
pages = {147--161},
title = {{Functional Programming With}},
year = {1998}
}
@misc{Leinster2010,
author = {Leinster, Tom},
title = {ninja yoneda lemma},
year = {2010}
}
@article{Kammar2013,
author = {Kammar, Ohad and Lindley, Sam and Oury, Nicolas},
doi = {10.1145/2500365.2500590},
file = {:Users/matt/Documents/paperarchive/Kammar, Lindley, Oury/Proceedings of the 18th ACM SIGPLAN international conference on Functional programming - ICFP '13/Kammar, Lindley, Oury - 2013 - Handlers in action.pdf:pdf},
isbn = {9781450323260},
issn = {0362-1340},
journal = {Proceedings of the 18th ACM SIGPLAN international conference on Functional programming - ICFP '13},
keywords = {algebraic effects,continuations,effect handlers,effect typing,haskell,instance monad,modularity},
pages = {145},
title = {{Handlers in action}},
url = {http://dl.acm.org/citation.cfm?doid=2500365.2500590},
year = {2013}
}
@article{Zdancewic,
author = {Zdancewic, S.},
doi = {10.1109/CSFW.2006.13},
file = {:Users/matt/Documents/paperarchive/Zdancewic/19th IEEE Computer Security Foundations Workshop (CSFW'06)/Zdancewic - Unknown - Encoding Information Flow in Haskell.pdf:pdf},
isbn = {0-7695-2615-2},
journal = {19th IEEE Computer Security Foundations Workshop (CSFW'06)},
pages = {16--16},
publisher = {Ieee},
title = {{Encoding Information Flow in Haskell}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=1648705}
}
@article{Li2008,
address = {New York, New York, USA},
author = {Li, Huiqing and Thompson, Simon},
doi = {10.1145/1636642.1636644},
file = {:Users/matt/Documents/paperarchive/Li, Thompson/Proceedings of the 2nd Workshop on Refactoring Tools - WRT '08/Li, Thompson - 2008 - Tool support for refactoring functional programs.pdf:pdf},
isbn = {9781605583396},
journal = {Proceedings of the 2nd Workshop on Refactoring Tools - WRT '08},
keywords = {erlang,hare,haskell,program analysis,program transformation,refactoring,semantics,wrangler},
pages = {1--4},
publisher = {ACM Press},
title = {{Tool support for refactoring functional programs}},
url = {http://portal.acm.org/citation.cfm?doid=1636642.1636644},
year = {2008}
}
@article{Moggi,
author = {Moggi, E.},
doi = {10.1109/LICS.1989.39155},
file = {:Users/matt/Documents/paperarchive/Moggi/1989 Proceedings. Fourth Annual Symposium on Logic in Computer Science/Moggi - Unknown - Computational lambda-calculus and monads.pdf:pdf},
isbn = {0-8186-1954-6},
journal = {[1989] Proceedings. Fourth Annual Symposium on Logic in Computer Science},
keywords = {monad},
mendeley-tags = {monad},
pages = {14--23},
publisher = {IEEE Comput. Soc. Press},
title = {{Computational lambda-calculus and monads}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=39155}
}
@article{Chen2014,
address = {New York, New York, USA},
author = {Chen, Yan and Acar, Umut a. and Tangwongsan, Kanat},
doi = {10.1145/2628136.2628150},
file = {:Users/matt/Documents/paperarchive/Chen, Acar, Tangwongsan/Proceedings of the 19th ACM SIGPLAN international conference on Functional programming - ICFP '14/Chen, Acar, Tangwongsan - 2014 - Functional programming for dynamic and large data with self-adjusting computation.pdf:pdf},
isbn = {9781450328739},
journal = {Proceedings of the 19th ACM SIGPLAN international conference on Functional programming - ICFP '14},
keywords = {granularity control,incremental graph algorithms,information-flow type sys-,performance,self-adjusting computation,tem},
pages = {227--240},
publisher = {ACM Press},
title = {{Functional programming for dynamic and large data with self-adjusting computation}},
url = {http://dl.acm.org/citation.cfm?doid=2628136.2628150},
year = {2014}
}
@article{Axelsson2012,
author = {Axelsson, Emil},
doi = {10.1145/2398856.2364573},
file = {:Users/matt/Documents/paperarchive/Axelsson/ACM SIGPLAN Notices/Axelsson - 2012 - A generic abstract syntax model for embedded languages.pdf:pdf},
isbn = {9781450310543},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
keywords = {at the expression problem,ded domain-specific languages,developed several embedded,embed-,generic programming,is highly,our motivation for looking,our research group has,practical,the expression problem},
month = {oct},
number = {9},
pages = {323},
title = {{A generic abstract syntax model for embedded languages}},
url = {http://dl.acm.org/citation.cfm?doid=2398856.2364573},
volume = {47},
year = {2012}
}
@article{Reynolds1993,
author = {Reynolds, John C.},
doi = {10.1007/BF01019459},
file = {:Users/matt/Documents/paperarchive/Reynolds/LISP and Symbolic Computation/Reynolds - 1993 - The discoveries of continuations.pdf:pdf},
issn = {0892-4635},
journal = {LISP and Symbolic Computation},
keywords = {a,abdali,abstract,account of the discoveries,and s,c,cepts by a,con-,continuation,continuation-passing style,f,fischer,h,j,k,l,m,mazurkiewicz,morris,of continuations and related,p,semantics,van wijngaarden,w,wadsworth,we give a brief},
month = {nov},
number = {3-4},
pages = {233--247},
title = {{The discoveries of continuations}},
url = {http://link.springer.com/10.1007/BF01019459},
volume = {6},
year = {1993}
}
@article{VanderPloeg2013,
address = {New York, New York, USA},
author = {van der Ploeg, Atze},
doi = {10.1145/2503778.2503783},
file = {:Users/matt/Documents/paperarchive/van der Ploeg/Proceedings of the 2013 ACM SIGPLAN symposium on Haskell - Haskell '13/van der Ploeg - 2013 - Monadic functional reactive programming.pdf:pdf},
isbn = {9781450323833},
journal = {Proceedings of the 2013 ACM SIGPLAN symposium on Haskell - Haskell '13},
keywords = {functional reactive programming,monads},
pages = {117},
publisher = {ACM Press},
title = {{Monadic functional reactive programming}},
url = {http://dl.acm.org/citation.cfm?doid=2503778.2503783},
year = {2013}
}
@article{Minoux1988a,
author = {Minoux, Michel},
file = {:Users/matt/Documents/paperarchive/Minoux/Processing/Minoux - 1988 - Resolution algorithm implementation 75005.pdf:pdf},
journal = {Processing},
title = {{Resolution algorithm implementation 75005}},
volume = {29},
year = {1988}
}
@article{Hackett2014,
address = {New York, New York, USA},
author = {Hackett, Jennifer and Hutton, Graham},
doi = {10.1145/2628136.2628142},
file = {:Users/matt/Documents/paperarchive/Hackett, Hutton/Proceedings of the 19th ACM SIGPLAN international conference on Functional programming - ICFP '14/Hackett, Hutton - 2014 - Workerwrappermakes itfaster.pdf:pdf},
isbn = {9781450328739},
journal = {Proceedings of the 19th ACM SIGPLAN international conference on Functional programming - ICFP '14},
keywords = {general recursion,improvement},
pages = {95--107},
publisher = {ACM Press},
title = {{Worker/wrapper/makes it/faster}},
url = {http://dl.acm.org/citation.cfm?doid=2628136.2628142},
year = {2014}
}
@article{Roberts2014,
address = {New York, New York, USA},
author = {Roberts, Matthew and Sloane, Anthony},
doi = {10.1145/2633628.2633629},
file = {:Users/matt/Documents/paperarchive/Roberts, Sloane/Proceedings of the 10th ACM SIGPLAN workshop on Generic programming - WGP '14/Roberts, Sloane - 2014 - Type inference for the spine view of data.pdf:pdf},
isbn = {9781450330428},
journal = {Proceedings of the 10th ACM SIGPLAN workshop on Generic programming - WGP '14},
keywords = {generic programming,pattern matching,spine view},
pages = {25--34},
publisher = {ACM Press},
title = {{Type inference for the spine view of data}},
url = {http://dl.acm.org/citation.cfm?doid=2633628.2633629},
year = {2014}
}
@article{Hyland2007,
abstract = {We consider the natural combinations of algebraic computational effects such as side-effects, exceptions, interactive input/output, and nondeterminism with continuations. Continuations are not an algebraic effect, but previously developed combinations of algebraic effects given by sum and tensor extend, with effort, to include commonly used combinations of the various algebraic effects with continuations. Continuations also give rise to a third sort of combination, that given by applying the continuations monad transformer to an algebraic effect. We investigate the extent to which sum and tensor extend from algebraic effects to arbitrary monads, and the extent to which Felleisen et al.'s C operator extends from continuations to its combination with algebraic effects. To do all this, we use Dubuc's characterisation of strong monads in terms of enriched large Lawvere theories. © 2007 Elsevier Ltd. All rights reserved.},
author = {Hyland, Martin and Levy, Paul Blain and Plotkin, Gordon and Power, John},
doi = {10.1016/j.tcs.2006.12.026},
file = {:Users/matt/Documents/paperarchive/Hyland et al/Theoretical Computer Science/Hyland et al. - 2007 - Combining algebraic effects with continuations.pdf:pdf},
isbn = {03043975},
issn = {03043975},
journal = {Theoretical Computer Science},
keywords = {Computational effect,Lawvere theory,Modularity,Monad},
number = {1-3},
pages = {20--40},
title = {{Combining algebraic effects with continuations}},
volume = {375},
year = {2007}
}
@article{Jin2012,
author = {Jin, Yier and Makris, Yiorgos},
doi = {10.1109/VTS.2012.6231062},
file = {:Users/matt/Documents/paperarchive/Jin, Makris/2012 IEEE 30th VLSI Test Symposium (VTS)/Jin, Makris - 2012 - Proof carrying-based information flow tracking for data secrecy protection and hardware trust.pdf:pdf},
isbn = {978-1-4673-1074-1},
journal = {2012 IEEE 30th VLSI Test Symposium (VTS)},
month = {apr},
pages = {252--257},
publisher = {Ieee},
title = {{Proof carrying-based information flow tracking for data secrecy protection and hardware trust}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=6231062},
year = {2012}
}
@article{Tsai2007,
author = {Tsai, Ta-chung and Russo, Alejandro and Hughes, John},
doi = {10.1109/CSF.2007.6},
file = {:Users/matt/Documents/paperarchive/Tsai, Russo, Hughes/20th IEEE Computer Security Foundations Symposium (CSF'07)/Tsai, Russo, Hughes - 2007 - A Library for Secure Multi-threaded Information Flow in Haskell.pdf:pdf},
isbn = {0-7695-2819-8},
issn = {1063-6900},
journal = {20th IEEE Computer Security Foundations Symposium (CSF'07)},
month = {jul},
pages = {187--202},
publisher = {Ieee},
title = {{A Library for Secure Multi-threaded Information Flow in Haskell}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=4271649},
year = {2007}
}
@article{Lindley2014,
address = {New York, New York, USA},
author = {Lindley, Sam},
doi = {10.1145/2633628.2633636},
file = {:Users/matt/Documents/paperarchive/Lindley/Proceedings of the 10th ACM SIGPLAN workshop on Generic programming - WGP '14/Lindley - 2014 - Algebraic effects and effect handlers for idioms and arrows.pdf:pdf},
isbn = {9781450330428},
journal = {Proceedings of the 10th ACM SIGPLAN workshop on Generic programming - WGP '14},
keywords = {algebraic effects,applicative functors,arrows,call-by-push-value,effect handlers,efficient implementa-,idioms,in both cases providing,monads,more space and time,tions than monadic alternatives},
pages = {47--58},
publisher = {ACM Press},
title = {{Algebraic effects and effect handlers for idioms and arrows}},
url = {http://dl.acm.org/citation.cfm?doid=2633628.2633636},
year = {2014}
}
@article{Russo2008,
address = {New York, New York, USA},
author = {Russo, Alejandro and Claessen, Koen and Hughes, John},
doi = {10.1145/1411286.1411289},
file = {:Users/matt/Documents/paperarchive/Russo, Claessen, Hughes/Proceedings of the first ACM SIGPLAN symposium on Haskell - Haskell '08/Russo, Claessen, Hughes - 2008 - A library for light-weight information-flow security in haskell.pdf:pdf},
isbn = {9781605580647},
journal = {Proceedings of the first ACM SIGPLAN symposium on Haskell - Haskell '08},
pages = {13},
publisher = {ACM Press},
title = {{A library for light-weight information-flow security in haskell}},
url = {http://portal.acm.org/citation.cfm?doid=1411286.1411289},
year = {2008}
}
@article{Angiuli2014,
address = {New York, New York, USA},
author = {Angiuli, Carlo and Morehouse, Edward and Licata, Daniel R. and Harper, Robert},
doi = {10.1145/2628136.2628158},
file = {:Users/matt/Documents/paperarchive/Angiuli et al/Proceedings of the 19th ACM SIGPLAN international conference on Functional programming - ICFP '14/Angiuli et al. - 2014 - Homotopical patch theory.pdf:pdf},
isbn = {9781450328739},
journal = {Proceedings of the 19th ACM SIGPLAN international conference on Functional programming - ICFP '14},
pages = {243--256},
publisher = {ACM Press},
title = {{Homotopical patch theory}},
url = {http://dl.acm.org/citation.cfm?doid=2628136.2628158},
year = {2014}
}
@article{Frigo1999,
author = {Frigo, M. and Leiserson, C.E. and Prokop, H. and Ramachandran, S.},
doi = {10.1109/SFFCS.1999.814600},
file = {:Users/matt/Documents/paperarchive/Frigo et al/40th Annual Symposium on Foundations of Computer Science (Cat. No.99CB37039)/Frigo et al. - 1999 - Cache-oblivious algorithms.pdf:pdf},
isbn = {0-7695-0409-4},
journal = {40th Annual Symposium on Foundations of Computer Science (Cat. No.99CB37039)},
pages = {285--297},
publisher = {IEEE Comput. Soc},
title = {{Cache-oblivious algorithms}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=814600},
year = {1999}
}
@article{Navarro2014,
author = {Navarro, Gonzalo},
file = {:Users/matt/Documents/paperarchive/Navarro/Journal of Discrete Algorithms/Navarro - 2014 - Wavelet trees for all.pdf:pdf},
journal = {Journal of Discrete Algorithms},
title = {{Wavelet trees for all}},
url = {http://www.sciencedirect.com/science/article/pii/S1570866713000610},
year = {2014}
}
@article{Ekblad2014,
address = {New York, New York, USA},
author = {Ekblad, Anton and Claessen, Koen},
doi = {10.1145/2633357.2633367},
file = {:Users/matt/Documents/paperarchive/Ekblad, Claessen/Proceedings of the 2014 ACM SIGPLAN symposium on Haskell - Haskell '14/Ekblad, Claessen - 2014 - A seamless, client-centric programming model for type safe web applications.pdf:pdf},
isbn = {9781450330411},
journal = {Proceedings of the 2014 ACM SIGPLAN symposium on Haskell - Haskell '14},
keywords = {distributed systems,network com-,web applications},
pages = {79--89},
publisher = {ACM Press},
title = {{A seamless, client-centric programming model for type safe web applications}},
url = {http://dl.acm.org/citation.cfm?doid=2633357.2633367},
year = {2014}
}
@article{Capriotti2014,
abstract = {Applicative functors are a generalisation of monads. Both allow the expression of effectful computations into an otherwise pure language, like Haskell. Applicative functors are to be preferred to monads when the structure of a computation is fixed a priori. That makes it possible to perform certain kinds of static analysis on applicative values. We define a notion of free applicative functor, prove that it satisfies the appropriate laws, and that the construction is left adjoint to a suitable forgetful functor. We show how free applicative functors can be used to implement embedded DSLs which can be statically analysed.},
archivePrefix = {arXiv},
arxivId = {1403.0749},
author = {Capriotti, Paolo and Kaposi, Ambrus},
doi = {10.4204/EPTCS.153.2},
eprint = {1403.0749},
file = {:Users/matt/Documents/paperarchive/Capriotti, Kaposi/Electronic Proceedings in Theoretical Computer Science/Capriotti, Kaposi - 2014 - Free Applicative Functors.pdf:pdf},
issn = {2075-2180},
journal = {Electronic Proceedings in Theoretical Computer Science},
keywords = {adjoints,and show that they,applicative functors,are equivalent,definition is correct,in haskell,in the sense that,it really,of free applicative functor,parametricity,section 2,section 5,we give two definitions,we prove that our},
number = {section 3},
pages = {2--30},
title = {{Free Applicative Functors}},
url = {http://arxiv.org/abs/1403.0749},
volume = {153},
year = {2014}
}
@article{Jeltsch2013,
address = {New York, New York, USA},
author = {Jeltsch, Wolfgang},
doi = {10.1145/2428116.2428128},
file = {:Users/matt/Documents/paperarchive/Jeltsch/Proceedings of the 7th workshop on Programming languages meets program verification - PLPV '13/Jeltsch - 2013 - Temporal logic with Until, functional reactive programming with processes, and concrete process categories.pdf:pdf},
isbn = {9781450318600},
journal = {Proceedings of the 7th workshop on Programming languages meets program verification - PLPV '13},
keywords = {afterwards we,and a categorical semantics,by giving a syntax,categorical semantics,category theory,causality,curry,functional reactive programming,howard cor-,operators,respondence,temporal logic with,until,we define an intuitionistic},
pages = {69},
publisher = {ACM Press},
title = {{Temporal logic with "Until", functional reactive programming with processes, and concrete process categories}},
url = {http://dl.acm.org/citation.cfm?doid=2428116.2428128},
year = {2013}
}
@article{Swierstra2001,
author = {Swierstra, S.D.},
doi = {10.1016/S1571-0661(05)80545-6},
file = {:Users/matt/Documents/paperarchive/Swierstra/Electronic Notes in Theoretical Computer Science/Swierstra - 2001 - Combinator Parsers From Toys to Tools.pdf:pdf},
issn = {15710661},
journal = {Electronic Notes in Theoretical Computer Science},
month = {aug},
number = {1},
pages = {38--59},
title = {{Combinator Parsers: From Toys to Tools}},
url = {http://linkinghub.elsevier.com/retrieve/pii/S1571066105805456},
volume = {41},
year = {2001}
}
@article{Bahr2014b,
author = {Bahr, Patrick},
doi = {10.2168/LMCS-10(2:6)2014},
editor = {Lynch, Christopher},
file = {:Users/matt/Documents/paperarchive/Bahr/Logical Methods in Computer Science/Bahr - 2014 - Partial Order Infinitary Term Rewriting.pdf:pdf},
issn = {18605974},
journal = {Logical Methods in Computer Science},
month = {jun},
number = {2},
pages = {1--52},
title = {{Partial Order Infinitary Term Rewriting}},
url = {http://www.lmcs-online.org/ojs/viewarticle.php?id=773},
volume = {10},
year = {2014}
}
@article{Liu2009,
author = {Liu, Hai and Cheng, Eric and Hudak, Paul},
doi = {10.1145/1631687.1596559},
file = {:Users/matt/Documents/paperarchive/Liu, Cheng, Hudak/ACM SIGPLAN Notices/Liu, Cheng, Hudak - 2009 - Causal commutative arrows and their optimization.pdf:pdf},
isbn = {9781605583327},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
keywords = {arrows,dataflow language,functional programming,functional reac-,pro-,stream processing,tive programming},
month = {aug},
number = {9},
pages = {35},
title = {{Causal commutative arrows and their optimization}},
url = {http://portal.acm.org/citation.cfm?doid=1631687.1596559},
volume = {44},
year = {2009}
}
@article{Foster2009,
abstract = {The need to edit source data through a view arises in a host of applications across many different areas of computing. Unfortunately, few existing systems provide support for updatable views. In practice, when they are needed, updatable views are usually implemented using two separate programs: one that computes the view from the source and another that handles updates. This rudimentary design is tedious for programmers, difcult to reason about, and a nightmare to maintain. This dissertation presents bidirectional programming languages, which provide an elegant and effective mechanism for describing updatable views. Unlike programs written in an ordi- nary language, which only work in one direction, programs in a bidirectional language can be run both forwards and backwards: from left to right, they describe functions that map sources to views, and from right to left, they describe functions that map updated views back to updated sources. Besides eliminating redundancy, these languages can be designed to ensure correctness, guaranteeing by construction that the two functions work well together. Starting from the foundations, we define a general semantic space of well-behaved bidirec- tional transformations called lenses. Then, building on this foundation, we describe a particular language for defining lenses on strings with syntax based on the familiar regular operators (union, concatenation, and Kleene star). We present extensions to the basic framework that address the subtle complications that arise when lenses are used to manipulate, data containing unimportant details, ordered data, and conodential data.},
author = {Foster, J.N.},
file = {:Users/matt/Documents/paperarchive/Foster/Computer/Foster - 2009 - Bidirectional programming languages.pdf:pdf},
isbn = {978-1-109-71013-7},
journal = {Computer},
pages = {269},
title = {{Bidirectional programming languages}},
url = {http://repository.upenn.edu/edissertations/56},
year = {2009}
}
@book{Hinze2013,
abstract = {Folds over inductive datatypes are well understood and widely used. In their plain form, they are quite restricted; but many disparate generalisations have been proposed that enjoy similar calculational benefits. There have also been attempts to unify the various generalisations: two prominent such unifications are the 'recursion schemes from comonads' of Uustalu, Vene and Pardo, and our own 'adjoint folds'. Until now, these two unified schemes have appeared incompatible. We show that this appearance is illusory: in fact, adjoint folds subsume recursion schemes from comonads. The proof of this claim involves standard constructions in category theory that are nevertheless not well known in functional programming: Eilenberg-Moore categories and bialgebras.},
author = {Hinze, Ralf and Wu, Nicolas and Gibbons, Jeremy},
booktitle = {ACM SIGPLAN Notices},
doi = {10.1145/2544174.2500578},
file = {:Users/matt/Documents/paperarchive/Hinze, Wu, Gibbons/ACM SIGPLAN Notices/Hinze, Wu, Gibbons - 2013 - Unifying structured recursion schemes.pdf:pdf},
isbn = {9781450323260},
issn = {03621340},
keywords = {adjunctions,bialge-,bras,comonads,distributive laws,recursion schemes},
number = {9},
pages = {209--220},
title = {{Unifying structured recursion schemes}},
url = {http://dl.acm.org/citation.cfm?doid=2544174.2500578},
volume = {48},
year = {2013}
}
@article{Eisenberg2013,
author = {Eisenberg, RA and Vytiniotis, D and Jones, SP and Weirich, Stephanie},
file = {:Users/matt/Documents/paperarchive/Eisenberg et al/Unknown/Eisenberg et al. - 2013 - Closed type families with overlapping equations (extended version).pdf:pdf},
keywords = {haskell,sys-,type families,type-level computation},
pages = {1--21},
title = {{Closed type families with overlapping equations (extended version)}},
url = {http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/axioms-extended.pdf},
year = {2013}
}
@article{Georges2007,
author = {Georges, Andy and Buytaert, Dries and Eeckhout, Lieven},
doi = {10.1145/1297105.1297033},
file = {:Users/matt/Documents/paperarchive/Georges, Buytaert, Eeckhout/ACM SIGPLAN Notices/Georges, Buytaert, Eeckhout - 2007 - Statistically rigorous java performance evaluation.pdf:pdf},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
keywords = {benchmarking,data analysis,java,methodol-},
month = {oct},
number = {10},
pages = {57},
title = {{Statistically rigorous java performance evaluation}},
url = {http://portal.acm.org/citation.cfm?doid=1297105.1297033},
volume = {42},
year = {2007}
}
@article{Kaplanyan2010,
address = {New York, New York, USA},
author = {Kaplanyan, Anton and Dachsbacher, Carsten},
doi = {10.1145/1730804.1730821},
file = {:Users/matt/Documents/paperarchive/Kaplanyan, Dachsbacher/Proceedings of the ACM SIGGRAPH Symposium on Interactive 3D Graphics and Games - I3D 10/Kaplanyan, Dachsbacher - 2010 - Cascaded light propagation volumes for real-time indirect illumination.pdf:pdf},
isbn = {9781605589398},
journal = {Proceedings of the ACM SIGGRAPH Symposium on Interactive 3D Graphics and Games - I3D 10},
keywords = {2008,2009b,global illumination,imperfect visibility,in this paper,method for rendering plausible,or by using screen-space,real-time rendering,ritschel et al,techniques,we present a novel},
pages = {99},
publisher = {ACM Press},
title = {{Cascaded light propagation volumes for real-time indirect illumination}},
url = {http://dl.acm.org/citation.cfm?doid=1730804.1730821},
year = {2010}
}
@article{Trifonov2003,
address = {New York, New York, USA},
author = {Trifonov, Valery},
doi = {10.1145/871895.871906},
file = {:Users/matt/Documents/paperarchive/Trifonov/Proceedings of the ACM SIGPLAN workshop on Haskell - Haskell '03/Trifonov - 2003 - Simulating quantified class constraints.pdf:pdf},
isbn = {1581137583},
journal = {Proceedings of the ACM SIGPLAN workshop on Haskell - Haskell '03},
keywords = {a,dictionaries,generator,instance,is an instance of,or a proof that,polymorphic types,represents an,the type,this instance declaration actually,type classes},
pages = {98--102},
publisher = {ACM Press},
title = {{Simulating quantified class constraints}},
url = {http://portal.acm.org/citation.cfm?doid=871895.871906},
year = {2003}
}
@article{Williams2014,
address = {New York, New York, USA},
author = {Williams, Thomas and Dagand, Pierre-{\'{E}}variste and R{\'{e}}my, Didier},
doi = {10.1145/2633628.2633631},
file = {:Users/matt/Documents/paperarchive/Williams, Dagand, R{\'{e}}my/Proceedings of the 10th ACM SIGPLAN workshop on Generic programming - WGP '14/Williams, Dagand, R{\'{e}}my - 2014 - Ornaments in practice.pdf:pdf},
isbn = {9781450330428},
journal = {Proceedings of the 10th ACM SIGPLAN workshop on Generic programming - WGP '14},
keywords = {code inference,datatypes,dependent types,generalized algebraic datatypes,ornament,refactoring},
pages = {15--24},
publisher = {ACM Press},
title = {{Ornaments in practice}},
url = {http://dl.acm.org/citation.cfm?doid=2633628.2633631},
year = {2014}
}
@article{Mcbridea,
author = {Mcbride, Conor},
file = {:Users/matt/Documents/paperarchive/Mcbride/Unknown/Mcbride - Unknown - A polynomial testing principle.pdf:pdf},
keywords = {4230,and phrases finite difference,dependently typed programming,digital object identifier 10,lipics,mechanical theorem proving,methods,p,testing coverage,xxx,yyy},
pages = {1--14},
title = {{A polynomial testing principle}},
volume = {i}
}
@article{Rivas2014,
abstract = {There are different notions of computation, the most popular being monads, applicative functors, and arrows. In this article we show that these three notions can be seen as monoids in a monoidal category. We demonstrate that at this level of abstraction one can obtain useful results which can be instantiated to the different notions of computation. In particular, we show how free constructions and Cayley representations for monoids translate into useful constructions for monads, applicative functors, and arrows. Moreover, the uniform presentation of all three notions helps in the analysis of the relation between them.},
archivePrefix = {arXiv},
arxivId = {1406.4823},
author = {Rivas, Exequiel and Jaskelioff, Mauro},
eprint = {1406.4823},
file = {:Users/matt/Documents/paperarchive/Rivas, Jaskelioff/Unknown/Rivas, Jaskelioff - 2014 - Notions of Computation as Monoids.pdf:pdf},
month = {may},
number = {June},
title = {{Notions of Computation as Monoids}},
url = {http://arxiv.org/abs/1406.4823},
year = {2014}
}
@book{Giorgidze2011,
author = {Ed, Ralf Hinze and Hutchison, David},
file = {:Users/matt/Documents/paperarchive/Giorgidze, Nilsson/Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)/Giorgidze, Nilsson - 2011 - Implementation and Application of Functional Languages.pdf:pdf},
isbn = {9783642415814},
title = {{Implementation and Application of Functional Languages}},
year = {2012}
}
@article{Bahr2012,
author = {Bahr, Patrick},
file = {:Users/matt/Documents/paperarchive/Bahr/Unknown/Bahr - 2012 - Modular Tree Automata.pdf:pdf},
pages = {263--299},
title = {{Modular Tree Automata}},
year = {2012}
}
@article{Awodey2010,
author = {Awodey, Steven},
file = {:Users/matt/Documents/paperarchive/Awodey/Elements/Awodey - 2010 - Category Theory.pdf:pdf},
journal = {Elements},
title = {{Category Theory}},
url = {http://elib.tu-darmstadt.de/tocs/19858928X.pdf},
year = {2010}
}
@article{Kennedy2007,
address = {New York, New York, USA},
author = {Kennedy, Andrew},
doi = {10.1145/1291151.1291179},
file = {:Users/matt/Documents/paperarchive/Kennedy/Proceedings of the 2007 ACM SIGPLAN international conference on Functional programming - ICFP '07/Kennedy - 2007 - Compiling with continuations, continued.pdf:pdf},
isbn = {9781595938152},
journal = {Proceedings of the 2007 ACM SIGPLAN international conference on Functional programming - ICFP '07},
keywords = {continuation passing style,continuations,functional programming languages,monads,op-,timizing compilation},
pages = {177},
publisher = {ACM Press},
title = {{Compiling with continuations, continued}},
url = {http://portal.acm.org/citation.cfm?doid=1291151.1291179},
year = {2007}
}
@article{Gibbons2014a,
author = {Gibbons, J and Wu, N},
file = {:Users/matt/Documents/paperarchive/Gibbons, Wu/ICFP, Sept/Gibbons, Wu - 2014 - Folding Domain− Specific Languages Deep and Shallow Embeddings.pdf:pdf},
isbn = {9781450328739},
journal = {ICFP, Sept},
title = {{Folding Domain− Specific Languages: Deep and Shallow Embeddings}},
url = {http://www.macs.hw.ac.uk/{~}dsg/events/ISS-AiPL-2014/materials/Gibbons/aipl-slides.pdf},
year = {2014}
}
@article{Gibbons2008,
abstract = {Abstract datatypes {\&}mdash; with public interfaces hiding private implementations$\backslash$n{\&}mdash; represent a form of codata rather than ordinary data, and$\backslash$nso proof methods for corecursive programs are the appropriate techniques$\backslash$nto use for reasoning with them. In particular, we show that the universal$\backslash$nproperties of unfold operators are perfectly suited for the task.$\backslash$nWe illustrate with the solution to a problem in the recent literature.},
author = {Gibbons, Jeremy},
doi = {10.1007/978-3-540-70594-9{\_}8},
file = {:Users/matt/Documents/paperarchive/Gibbons/Mathematics of Program Construction/Gibbons - 2008 - Unfolding abstract datatypes.pdf:pdf},
isbn = {978-3-540-70593-2},
issn = {0302-9743},
journal = {Mathematics of Program Construction},
pages = {110--133},
title = {{Unfolding abstract datatypes}},
url = {http://link.springer.com/chapter/10.1007/978-3-540-70594-9{\_}8},
volume = {5133 LNCS},
year = {2008}
}
@inproceedings{Ploeg2014,
abstract = {A series of list appends or monadic binds for many monads performs algorithmically worse when left-associated. Continuation-passing style (CPS) is well-known to cure this severe dependence of performance on the association pattern. The advantage of CPS dwindles or disappears if we have to examine or modify the intermediate result of a series of appends or binds, before continuing the series. Such examination is frequently needed, for example, to control search in non-determinism monads. We present an alternative approach that is just as general as CPS but more robust: it makes series of binds and other such operations efficient regardless of the association pattern-- and also provides efficient access to intermediate results. The key is to represent such a conceptual sequence as an efficient sequence data structure. Efficient sequence data structures from the literature are homogeneous and cannot be applied as they are in a type-safe way to series of monadic binds. We generalize them to type aligned sequences and show how to construct their (assuredly order-preserving) implementations. We demonstrate that our solution solves previously undocumented, severe performance problems in iteratees, LogicT transformers, free monads and extensible effects.},
author = {Ploeg, Atze Van Der and Kiselyov, Oleg},
booktitle = {Haskell '14 Proceedings of the 2014 ACM SIGPLAN symposium on Haskell},
doi = {10.1145/2633357.2633360},
isbn = {9781450330411},
keywords = {data structures,monads,performance,reﬂection},
pages = {133--144},
publisher = {ACM},
series = {Haskell '14},
shorttitle = {Reflection Without Remorse},
title = {{Reflection without Remorse}},
url = {http://homepages.cwi.nl/{~}ploeg/papers/zseq.pdf},
year = {2014}
}
@article{Bahr2014,
author = {Bahr, Patrick},
file = {:Users/matt/Documents/paperarchive/Bahr/Proceedings of the 10th ACM SIGPLAN workshop on {\ldots}/Bahr - 2014 - Composing and decomposing data types a closed type families implementation of data types {\`{a}} la carte.pdf:pdf},
isbn = {9781450330428},
journal = {Proceedings of the 10th ACM SIGPLAN workshop on {\ldots}},
keywords = {closed type families,expression problem,two-level},
pages = {71--82},
title = {{Composing and decomposing data types: a closed type families implementation of data types {\`{a}} la carte}},
url = {http://dl.acm.org/citation.cfm?id=2633635},
year = {2014}
}
@article{OConnor2011,
abstract = {This paper gives two new categorical characterisations of lenses: one as a coalgebra of the store comonad, and the other as a monoidal natural transformation on a category of a certain class of coalgebras. The store comonad of the first characterisation can be generalized to a Cartesian store comonad, and the coalgebras of this Cartesian store comonad turn out to be exactly the Biplates of the Uniplate generic programming library. On the other hand, the monoidal natural transformations on functors can be generalized to work on a category of more specific coalgebras. This generalization turns out to be the type of compos from the Compos generic programming library. A theorem, originally conjectured by van Laarhoven, proves that these two generalizations are isomorphic, thus the core data types of the Uniplate and Compos libraries supporting generic program on single recursive types are the same. Both the Uniplate and Compos libraries generalize this core functionality to support mutually recursive types in different ways. This paper proposes a third extension to support mutually recursive data types that is as powerful as Compos and as easy to use as Uniplate. This proposal, called Multiplate, only requires rank 3 polymorphism in addition to the normal type class mechanism of Haskell.},
archivePrefix = {arXiv},
arxivId = {1103.2841},
author = {O'Connor, Russell},
eprint = {1103.2841},
file = {:Users/matt/Documents/paperarchive/O'Connor/Unknown/O'Connor - 2011 - Functor is to Lens as Applicative is to Biplate Introducing Multiplate.pdf:pdf},
keywords = {applicative,coalgebra,comonad,functional reference,generic programming,lens,monoidal functor,monoidal natural transformation},
pages = {1--21},
title = {{Functor is to Lens as Applicative is to Biplate: Introducing Multiplate}},
url = {http://arxiv.org/abs/1103.2841},
year = {2011}
}
@article{Snyder1992,
author = {Snyder, John M.},
doi = {10.1145/142920.134024},
file = {:Users/matt/Documents/paperarchive/Snyder/ACM SIGGRAPH Computer Graphics/Snyder - 1992 - Interval analysis for computer graphics.pdf:pdf},
issn = {00978930},
journal = {ACM SIGGRAPH Computer Graphics},
month = {jul},
number = {2},
pages = {121--130},
title = {{Interval analysis for computer graphics}},
url = {http://portal.acm.org/citation.cfm?doid=142920.134024},
volume = {26},
year = {1992}
}
@article{Baez1997,
abstract = {An n-category is some sort of algebraic structure consisting of objects, morphisms between objects, 2-morphisms between morphisms, and so on up to n-morphisms, together with various ways of composing them. We survey various concepts of n-category, with an emphasis on `weak' n-categories, in which all rules governing the composition of j-morphisms hold only up to equivalence. (An n-morphism is an equivalence if it is invertible, while a j-morphism for j < n is an equivalence if it is invertible up to a (j+1)-morphism that is an equivalence.) We discuss applications of weak n-categories to various subjects including homotopy theory and topological quantum field theory, and review the definition of weak n-categories recently proposed by Dolan and the author.},
archivePrefix = {arXiv},
arxivId = {q-alg/9705009},
author = {Baez, John C.},
eprint = {9705009},
file = {:Users/matt/Documents/paperarchive/Baez/Unknown/Baez - 1997 - An Introduction to n-Categories.pdf:pdf},
month = {may},
pages = {34},
primaryClass = {q-alg},
title = {{An Introduction to n-Categories}},
url = {http://arxiv.org/abs/q-alg/9705009},
year = {1997}
}
@article{Kiselyov2009,
abstract = {Two general techniques for implementing a domain-specific language (DSL) with less overhead are the finally-tagless embedding of object programs and the direct-style representation of side effects. We use these techniques to build a DSL for probabilistic programming, for expressing countable probabilistic models and performing exact inference and importance sampling on them. Our language is embedded as an ordinary OCaml library and represents probability distributions as ordinary OCaml programs. We use delimited continuations to reify probabilistic programs as lazy search trees, which inference algorithms may traverse without imposing any interpretive overhead on deterministic parts of a model. We thus take advantage of the existing OCaml implementation to achieve competitive performance and ease of use. Inference algorithms can easily be embedded in probabilistic programs themselves.},
author = {Kiselyov, Oleg and Shan, Chung Chieh},
doi = {10.1007/978-3-642-03034-5{\_}17},
file = {:Users/matt/Documents/paperarchive/Kiselyov, Shan/Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)/Kiselyov, Shan - 2009 - Embedded probabilistic programming.pdf:pdf},
isbn = {3642030335},
issn = {03029743},
journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
pages = {360--384},
title = {{Embedded probabilistic programming}},
volume = {5658 LNCS},
year = {2009}
}
@article{Reynolds,
author = {Reynolds, J.C.},
doi = {10.1109/LICS.2002.1029817},
file = {:Users/matt/Documents/paperarchive/Reynolds/Proceedings 17th Annual IEEE Symposium on Logic in Computer Science/Reynolds - Unknown - Separation logic a logic for shared mutable data structures.pdf:pdf},
isbn = {0-7695-1483-9},
journal = {Proceedings 17th Annual IEEE Symposium on Logic in Computer Science},
number = {1},
pages = {55--74},
publisher = {IEEE Comput. Soc},
title = {{Separation logic: a logic for shared mutable data structures}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=1029817},
volume = {1}
}
@book{Koslow1992,
author = {Koslow, Arnold},
doi = {10.1017/CBO9780511609206.025},
file = {:Users/matt/Documents/paperarchive/Koslow/Unknown/Koslow - 1992 - Completeness.pdf:pdf},
isbn = {9780521412674},
pages = {229--236},
title = {{Completeness}},
year = {1992}
}
@article{Bauer2014,
author = {Bauer, Andrej and Pretnar, Matija},
doi = {10.1016/j.jlamp.2014.02.001},
file = {:Users/matt/Documents/paperarchive/Bauer, Pretnar/Journal of Logical and Algebraic Methods in Programming/Bauer, Pretnar - 2014 - Programming with algebraic effects and handlers.pdf:pdf},
issn = {23522208},
journal = {Journal of Logical and Algebraic Methods in Programming},
month = {mar},
pages = {1--25},
title = {{Programming with algebraic effects and handlers}},
url = {http://linkinghub.elsevier.com/retrieve/pii/S2352220814000194},
year = {2014}
}
@article{Wu2014a,
address = {New York, New York, USA},
annote = {Backtrack -{\&}gt; Parser},
author = {Wu, Nicolas and Schrijvers, Tom and Hinze, Ralf},
doi = {10.1145/2633357.2633358},
file = {:Users/matt/Documents/paperarchive/Wu, Schrijvers, Hinze/Proceedings of the 2014 ACM SIGPLAN symposium on Haskell - Haskell '14/Wu, Schrijvers, Hinze - 2014 - Effect handlers in scope(2).pdf:pdf},
isbn = {9781450330411},
journal = {Proceedings of the 2014 ACM SIGPLAN symposium on Haskell - Haskell '14},
keywords = {ICFP 2014,effect handlers,haskell,modularity,monads,syntax},
mendeley-tags = {ICFP 2014},
pages = {1--12},
publisher = {ACM Press},
title = {{Effect handlers in scope}},
url = {http://dl.acm.org/citation.cfm?doid=2633357.2633358},
year = {2014}
}
@article{Sculthorpe2014,
abstract = {When writing transformation systems, a significant amount of engineering effort goes into setting up the infrastructure needed to direct individual transformations to specific targets in the data being transformed. Strategic programming languages provide general-purpose infrastructure for this task, which the author of a transformation system can use for any algebraic data structure. The Kansas University Rewrite Engine (KURE) is a typed strategic programming language, implemented as a Haskell-embedded domain-specific language. KURE is designed to support typed transformations over typed data, and the main challenge is how to make such transformations compatible with generic traversal strategies that should operate over any type. Strategic programming in a typed setting has much in common with datatype-generic programming. Compared to other approaches to datatype-generic programming, the distinguishing feature of KURE's solution is that the user can configure the behaviour of traversals based on the location of each datum in the tree, beyond their behaviour being determined by the type of each datum. This article describes KURE's approach to assigning types to generic traversals, and the implementation of that approach. We also compare KURE, its design choices, and their consequences, with other approaches to strategic and datatype-generic programming.},
author = {Sculthorpe, Neil and Frisby, Nicolas and Gill, Andy},
doi = {10.1017/S0956796814000185},
file = {:Users/matt/Documents/paperarchive/Sculthorpe, Frisby, Gill/Journal of Functional Programming/Sculthorpe, Frisby, Gill - 2014 - The Kansas University rewrite engine.pdf:pdf},
issn = {1469-7653},
journal = {Journal of Functional Programming},
number = {04},
pages = {434--473},
title = {{The Kansas University rewrite engine}},
url = {http://journals.cambridge.org/article{\_}S0956796814000185$\backslash$nhttp://journals.cambridge.org/action/displayAbstract?fromPage=online{\&}aid=9348612{\&}fileId=S0956796814000185$\backslash$nhttp://journals.cambridge.org/action/displayFulltext?type=1{\&}fid=9348614{\&}jid=JFP{\&}volumeId=24},
volume = {24},
year = {2014}
}
@article{Voigtlander2008,
abstract = {We present a low-effort program transformation to improve the efficiency of computations over free monads in Haskell. The development is calculational and carried out in a generic setting, thus applying to a variety of datatypes. An important aspect of our approach is the utilisation of type class mechanisms to make the transformation as transparent as possible, requiring no restructuring of code at all. There is also no extra support necessary from the compiler (apart from an up-to-date type checker). Despite this simplicity of use, our technique is able to achieve true asymptotic runtime improvements. We demonstrate this by examples for which the complexity is reduced from quadratic to linear.},
author = {Voigtl{\"{a}}nder, Janis},
doi = {10.1007/978-3-540-70594-9{\_}20},
file = {:Users/matt/Documents/paperarchive/Voigtl{\"{a}}nder/Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)/Voigtl{\"{a}}nder - 2008 - Asymptotic improvement of computations over free monads.pdf:pdf},
isbn = {3540705937},
issn = {03029743},
journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
keywords = {codensity,free monad},
mendeley-tags = {codensity,free monad},
number = {March 2005},
pages = {388--403},
title = {{Asymptotic improvement of computations over free monads}},
volume = {5133 LNCS},
year = {2008}
}
@article{Oury2008,
author = {Oury, Nicolas and Swierstra, Wouter},
doi = {10.1145/1411203.1411213},
file = {:Users/matt/Documents/paperarchive/Oury, Swierstra/ACM SIGPLAN Notices/Oury, Swierstra - 2008 - The power of Pi.pdf:pdf},
isbn = {9781595939197},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
month = {sep},
number = {9},
pages = {39},
title = {{The power of Pi}},
url = {http://portal.acm.org/citation.cfm?doid=1411203.1411213},
volume = {43},
year = {2008}
}
@article{Oliveira2012,
author = {Oliveira, Bruno C.d.S. and Cook, William R.},
doi = {10.1145/2398856.2364541},
file = {:Users/matt/Documents/paperarchive/Oliveira, Cook/ACM SIGPLAN Notices/Oliveira, Cook - 2012 - Functional programming with structured graphs.pdf:pdf},
isbn = {9781450310543},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
keywords = {24,a combination of algebraic,be used to model,can,datatypes and mutable references,graphs,haskell,however this requires ex-,in impure functional languages,including ml or ocaml,parametric hoas,sharing and cycles},
month = {oct},
number = {9},
pages = {77},
title = {{Functional programming with structured graphs}},
url = {http://dl.acm.org/citation.cfm?doid=2398856.2364541},
volume = {47},
year = {2012}
}
@article{Marlow,
author = {Marlow, Simon},
file = {:Users/matt/Documents/paperarchive/Marlow/Unknown/Marlow - Unknown - Parallel and Concurrent Programming in Haskell.pdf:pdf},
keywords = {concurrency},
mendeley-tags = {concurrency},
title = {{Parallel and Concurrent Programming in Haskell}},
url = {http://community.haskell.org/{~}simonmar/par-tutorial.pdf}
}
@article{Bergstrom2014,
address = {New York, New York, USA},
author = {Bergstrom, Lars and Fluet, Matthew and Le, Matthew and Reppy, John and Sandler, Nora},
doi = {10.1145/2628136.2628153},
file = {:Users/matt/Documents/paperarchive/Bergstrom et al/Proceedings of the 19th ACM SIGPLAN international conference on Functional programming - ICFP '14/Bergstrom et al. - 2014 - Practical and effective higher-order optimizations.pdf:pdf},
isbn = {9781450328739},
journal = {Proceedings of the 19th ACM SIGPLAN international conference on Functional programming - ICFP '14},
keywords = {control-flow analysis,inlining,optimization},
pages = {81--93},
publisher = {ACM Press},
title = {{Practical and effective higher-order optimizations}},
url = {http://dl.acm.org/citation.cfm?doid=2628136.2628153},
year = {2014}
}
@article{Knauff2014a,
abstract = {The choice of an efficient document preparation system is an important decision for any academic researcher. To assist the research community, we report a software usability study in which 40 researchers across different disciplines prepared scholarly texts with either Microsoft Word or LaTeX. The probe texts included simple continuous text, text with tables and subheadings, and complex text with several mathematical equations. We show that LaTeX users were slower than Word users, wrote less text in the same amount of time, and produced more typesetting, orthographical, grammatical, and formatting errors. On most measures, expert LaTeX users performed even worse than novice Word users. LaTeX users, however, more often report enjoying using their respective software. We conclude that even experienced LaTeX users may suffer a loss in productivity when LaTeX is used, relative to other document preparation systems. Individuals, institutions, and journals should carefully consider the ramifications of this finding when choosing document preparation strategies, or requiring them of authors.},
author = {Knauff, Markus and Nejasmic, Jelica},
doi = {10.1371/journal.pone.0115069},
file = {:Users/matt/Documents/paperarchive/Knauff, Nejasmic/PloS one/Knauff, Nejasmic - 2014 - An Efficiency Comparison of Document Preparation Systems Used in Academic Research and Development.pdf:pdf},
issn = {1932-6203},
journal = {PloS one},
month = {jan},
number = {12},
pages = {e115069},
pmid = {25526083},
title = {{An Efficiency Comparison of Document Preparation Systems Used in Academic Research and Development.}},
url = {http://www.ncbi.nlm.nih.gov/pubmed/25526083},
volume = {9},
year = {2014}
}
@article{Licata2008,
author = {Licata, Daniel R. and Zeilberger, Noam and Harper, Robert},
doi = {10.1109/LICS.2008.48},
file = {:Users/matt/Documents/paperarchive/Licata, Zeilberger, Harper/2008 23rd Annual IEEE Symposium on Logic in Computer Science/Licata, Zeilberger, Harper - 2008 - Focusing on Binding and Computation.pdf:pdf},
isbn = {978-0-7695-3183-0},
issn = {1043-6871},
journal = {2008 23rd Annual IEEE Symposium on Logic in Computer Science},
month = {jun},
pages = {241--252},
publisher = {Ieee},
title = {{Focusing on Binding and Computation}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=4557915},
year = {2008}
}
@article{Magalhaes2010,
address = {New York, New York, USA},
author = {Magalh{\~{a}}es, Jos{\'{e}} Pedro and Dijkstra, Atze and Jeuring, Johan and L{\"{o}}h, Andres},
doi = {10.1145/1863523.1863529},
file = {:Users/matt/Documents/paperarchive/Magalh{\~{a}}es et al/Proceedings of the third ACM Haskell symposium on Haskell - Haskell '10/Magalh{\~{a}}es et al. - 2010 - A generic deriving mechanism for Haskell.pdf:pdf},
isbn = {9781450302524},
journal = {Proceedings of the third ACM Haskell symposium on Haskell - Haskell '10},
pages = {37},
publisher = {ACM Press},
title = {{A generic deriving mechanism for Haskell}},
url = {http://portal.acm.org/citation.cfm?doid=1863523.1863529},
year = {2010}
}
@article{Krishnaswami2013,
author = {Krishnaswami, Neelakantan R.},
doi = {10.1145/2544174.2500588},
file = {:Users/matt/Documents/paperarchive/Krishnaswami/ACM SIGPLAN Notices/Krishnaswami - 2013 - Higher-order functional reactive programming without spacetime leaks.pdf:pdf},
isbn = {9781450323260},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
keywords = {capabilities,dataflow,functional reactive programming,guarded recursion,kripke logical re-,lations,temporal logic},
month = {nov},
number = {9},
pages = {221--232},
title = {{Higher-order functional reactive programming without spacetime leaks}},
url = {http://dl.acm.org/citation.cfm?doid=2544174.2500588},
volume = {48},
year = {2013}
}
@article{Ahman2014,
author = {Ahman, Danel and Uustalu, Tarmo},
doi = {10.1016/j.entcs.2014.10.003},
file = {:Users/matt/Documents/paperarchive/Ahman, Uustalu/Electronic Notes in Theoretical Computer Science/Ahman, Uustalu - 2014 - Coalgebraic Update Lenses.pdf:pdf},
issn = {15710661},
journal = {Electronic Notes in Theoretical Computer Science},
keywords = {acts,algebras,bialgebras,coalgebras,comonads,directed containers,distributive laws,lenses,liftings,monads,monoid},
pages = {25--48},
publisher = {Elsevier B.V.},
title = {{Coalgebraic Update Lenses}},
url = {http://linkinghub.elsevier.com/retrieve/pii/S157106611400070X},
volume = {308},
year = {2014}
}
@article{Fisher2014,
address = {New York, New York, USA},
author = {Fisher, Kathleen},
doi = {10.1145/2628136.2628165},
file = {:Users/matt/Documents/paperarchive/Fisher/Proceedings of the 19th ACM SIGPLAN international conference on Functional programming - ICFP '14/Fisher - 2014 - Using formal methods to enable more secure vehicles.pdf:pdf},
isbn = {9781450328739},
journal = {Proceedings of the 19th ACM SIGPLAN international conference on Functional programming - ICFP '14},
pages = {1--1},
publisher = {ACM Press},
title = {{Using formal methods to enable more secure vehicles}},
url = {http://dl.acm.org/citation.cfm?doid=2628136.2628165},
year = {2014}
}
@article{Lammel2013,
author = {L{\"{a}}mmel, Ralf and Thompson, Simon and Kaiser, Markus},
doi = {10.1016/j.scico.2011.11.006},
file = {:Users/matt/Documents/paperarchive/L{\"{a}}mmel, Thompson, Kaiser/Science of Computer Programming/L{\"{a}}mmel, Thompson, Kaiser - 2013 - Programming errors in traversal programs over structured data.pdf:pdf},
issn = {01676423},
journal = {Science of Computer Programming},
keywords = {traversal programming,traversal strategies},
month = {oct},
number = {10},
pages = {1770--1808},
publisher = {Elsevier B.V.},
title = {{Programming errors in traversal programs over structured data}},
url = {http://linkinghub.elsevier.com/retrieve/pii/S0167642311002061},
volume = {78},
year = {2013}
}
@misc{Kmett,
author = {Kmett, Edward},
title = {{No Title}},
year = {2011}
}
