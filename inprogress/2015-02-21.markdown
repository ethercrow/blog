---
title: Idiom Brackets with associated types
---

Ollie Charles' recent post to the Haskell café sparked a lot of discussion aboutt he possibility of adding compiler support for idiom brackets. For the unitiated, the extension would perform the following syntactic transformation of code.

```
foo :: Applicative m => m Int
foo = (| (+) f g |)
--
foo = (+) <$> f <*> g
```

Ollie goes into much more detail in the draft proposal about the merits of his [proposal](https://ocharles.org.uk/tmp/IdiomBrackets.html). Personally I stand ambivilant but what is intriging is that it is possible[^1] to implement idiom brackets in plain haskell.

<!-- more -->

# Variadic Functions

It may first be worthwhile to explain how variadic functions such as `printf` can be defined. Our goal will be to define a function `concatAll` which behaves as follows.

```
> concatAll "a"
"a"
> concatAll "a" "b" "c"
"abc"
```
At first glance, it may seem that `concatAll` can't possibly be well typed. In the first instance it appears that `concatAll :: String -> String` but the second instance appears to take three arguments.

```
class ConcatResult r where
    cc :: String -> r

instance ConcatResult String where
    cc = id

instance ConcatResult r => ConcatResult (String -> r) where
    cc s1 s2 = cc (s1 ++ s2)

concatAll :: (ConcatResult r) => String -> r
concatAll = cc
```

# Idioms

Turning to idiom brackets, the situation appears to be very similar. In fact in
[Applicative programming with
effects](http://strictlypositive.org/IdiomLite.pdf) McBride leaves the
implementation of such a function as an exercise. There are just two complicating factors.

1. The required type of function is not consistent.
2. We must fix the `i` we wish to operate under.

A simple way to implement this is to use a multi parameter typeclass. `i` indicates the context which must remain consistent, `f` the type of the argument and `g` the type of the return value.

The implementation given by McBride is the following. Note that we can use a function dependency as `g` uniquely determins what `f` and `i` must be.[^2]

```
data Ii = Ii


class Applicative i => Idiom i f g | g -> f i where
  idiomatic :: i f -> g

instance (Applicative i) => Idiom i x (Ii -> i x) where
  idiomatic :: i x -> Ii -> i x
  idiomatic res Ii = res

instance Idiom i f g = Idiom i (s -> f) (i s -> g) where
  idiomatic :: i (s -> f) -> i s -> g
  idiomatic l r = idiomatic (l <*> r)

iI :: Idiom i f g => f -> g
iI = idiomatic . pure

f :: Identity Int
f = iI (+) (pure 5) (pure 6) Ii
```

Using `iI` to denote the start of the bracket and `Ii` to show the end. These
type class instances look quite mystical at first but adding the instance
signatures makes the implementations much easier to understand.

The first instance tells us how to behave when there is only one argument. The
second instance allows us to deal with multiple arguments. `idiomatic`


# Type Families

But, I hear you say. Type class hackery of this kind may have been necessary
several years ago but now we have better, more powerful tools to crack open
tasty type system morsels. Type families usually provide us with a level of fine
grained control which typeclasses unable to afford us.

This case is no different, modern technologies allow us to clean up the
implementation by explicitly specifying how `i` and `f` can be inferred from
`g`.

```
class Applicative (I g) => Idiomatic g where
   type I g :: * -> *
   type F g
   idiomatic :: (I g) (F g) -> g

instance Applicative i   => Idiomatic (Ii -> i x) where
  type I (Ii -> i x) = i
  type F (Ii -> i x) = x
  idiomatic xi Ii     = xi

instance (Idiomatic g, i ~ I g)  => Idiomatic (i s -> g) where
  type I (i s -> g) = i
  type F (i s -> g) = s -> F g
  idiomatic :: i (s -> f) -> i s -> g
  idiomatic sfi si    = idiomatic (sfi <*> si)
```

Infact, this implementation provides much better error messages.

Given a malformed version of our current example, applying `F` in your head
gives a sensible error message. [^ff] On the other hand, overapplication still
gives the programmer little help finding her error.

[^ff]:
```
F (Identity a0 -> Ii -> Identity Int)
=
a0 -> F (Ii -> Identity Int)
=
a0 -> Int
```

```haskell
f :: Identity Int
f = iI (+) (Identity 5) Ii
```
```
Couldn't match type Int with ‘a0 -> a0’
Expected type: F (Identity a0 -> Ii -> Identity Int)
  Actual type: a0 -> a0 -> a0 …
In the first argument of ‘iI’, namely ‘(+)’
In the expression: iI (+) (Identity 5) Ii
```

Which is extremely similar to the normal error message generated by a similar
expression.

```
g :: Int
g = (+) 5
```

```
Couldn't match expected type ‘Int’ with actual type ‘a0 -> a0’
Probable cause: ‘(+)’ is applied to too few arguments
In the expression: (+) 5
In an equation for ‘g’: g = (+) 5
```

# Generalisation

Adam Vogt slightly generalised this idea away from Applicatives so that the
construct could be used to intersperse any binary operator given appropiate
direction.[^3] Leveraging the `ApplyAB` class[^ From `HList`  originally]
(which indicates how one can turn an `a` into a `b`)
his implementation is as follows.

```

class InfixF f as t where
    iIwith :: f   -- How to combine
           -> as
           -> t

data Ii = Ii

instance (as ~ as') => InfixF f as (Ii -> as') where
    iIwith f as Ii = as

instance (ApplyAB f (as,a) as', InfixF f as' b) => InfixF f as (a -> b) where
    iIwith f as a = iIwith f (applyAB f (as,a) :: as')


-- Copied from HList
class ApplyAB f a b where
  applyAB :: f -> a -> b


```

We can then implement `iI` with this machinery (and also `concatAll`[^concat]).

```
iI :: forall f as t. InfixF (App f) as t => as -> t
iI = iIwith (App :: App f)

data App (f :: * -> *) = App

-- How we can turn `(f (a -> b), f a)` into `(f b)`
instance (ApplyAB (App f) (f (a -> b), f a) (f b) where
  applyAB _ = uncurry (<*>)
```









[^1]: With some caveats..

[^2]: To see this, consider what the type of `idiomatic x y` where `x :: m (a -> b)` and `y :: m a` must be.
      `idiomatic :: m (a -> b) -> m a -> m b` so we can see that  `i :: m`, `f :: (a -> b)` and `r :: m a -> m b`.

[^3]: Prompted by Chris Done's
[post](https://mail.haskell.org/pipermail/haskell-cafe/2015-February/118257.html) proposing the `infix` keyword.

[^concat]: Also note that with this machinery we can implement `concatAll`.
           ```
  data Concat = Concat

  instance ApplyAB Concat (String, String) String where
    applyAB _ = uncurry (++)

  concatAll :: InfixF Concat as r => as -> r
  concatAll = iIwith Concat

  m :: String
  m = concatAll "a" "b" Ii
  ```
